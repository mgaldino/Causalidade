--- 
title: "Curso de Inferência Causal"
author: "Manoel Galdino"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
---

# Introdução

Aqui pretendo guardar minhas notas de aula para meu curso de causalidade na pós-graduação. É uma forma de organizar e sistematizar meu estudo sobre o tema.

## Revisão de Regressão

Comecemos pelo modelo de regressão populacional dado por:
$$y = \beta_0 + \beta_1 x + u$$

As suposições básicas do modelo são:

1. Média do erro é zero (sem perda de generalidade): $\mathbb{E}[u] = 0$

2. Independência na média do erro: $\mathbb{E}[u|x] = \mathbb{E}[u]$. Essa é a suposição mais consequente do modelo de regressão. Como é sobre o termo de erro, não é testável. Um exemplo é útil para entender o que significa essa suposição. Suponha que estamos interessados no efeito do gasto de campanha ($x$) sobre o voto ($y$). O termo de erro $e$ seria a qualidade da candidata, não observável. A suposição implica então que a qualidade média das candidatas que gastam 100 mil reais é a mesma das que gastam 500 mil e um milhão (e assim por diante). Se candidatas melhores arrecadam mais dinheiro e, portanto, gastam mais, a suposição foi violada.

Conectando 1 e 2, temos: $\mathbb{E}[u|x] = 0$. Essa suposição é chamada de "média condicional zero" ou "esperança condicional zero" do termo de erro. Ela implica que:
$\mathbb{E}[y|x] = \beta_0 + \beta_1 x$. Essa equação é chamada de Conditional Expectation Function, ou CEF.

De posse de uma amostra aleatória simples, podemos derivar os estimadores de mínimos quadrados (MQO ou OLS na sigla em inglês). Vou pular os passos da derivação. Para nós, o importante é lembrar a fórmula do $\hat{\beta_1}$:

$\hat{\beta_1} = \frac{\text{covariância amostral}}{\text{variância amostral}} = \frac{\sum_{i=1}^n(x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^n(x_i - \bar{x})^2}$

E $\hat{\beta_0} = \bar{y}  - \hat{\beta_1}\bar{x}$.

Podemos então demonstrar que o estimador é não-viesado. Para isso, é necessário supor que o modelo é linear nos parâmetros (não nas variáveis), temos uma amostra aleatória simples da população, existe variância no preditor (para não dividir por zero na fórmula do estimador de OLS) e a média condicional zero.

### Teorema da Anatomia da Regressão

Esse teorema, também conhecido como teorema de Frisch, Waugh e Lovell ou Frisch-Waugh-Lovell, é útil para ajudar a entender regressão múltipla.
Suponha que nosso modelo possui $2$ preditores:

$y_i=\beta_0+\beta_1 x_{1i}+ \beta_2 x_{2i}+ e_i$.

Agora, suponha que, em vez de rodar a regressão acima, eu rodo uma regressão (chamada de auxiliar) em que $x_1$ é a variável dependente, e $x_2$ o único preditor.

$x_{1i}=\gamma_0+\gamma_{1}x_{2i} + f_i$.

E os resíduos são dados por: $\tilde{x}{1i}=x{1i} - \widehat{x}{1i}$. Então, é possível mostrar que: $\beta_1 = \frac{C(y_i, \tilde{x}{1i})}{V(\tilde{x}_{1i})}$. O que essa fórmula nos diz é que o efeito de $\beta_1$ é a covariância entre a variável dependente e o resíduo da regressão auxiliar, isto é, a parte de $x_1$ não explicada pelos demais preditores.

Vamos visualizar essa relação com um exemplo do livro do Scott Cunningham:

```{r}
library(tidyverse)
library(haven)

read_data <- function(df) {
  full_path <- paste0("https://github.com/scunning1975/mixtape/raw/master/",
                      df)
  haven::read_dta(full_path)
}

auto <-
  read_data("auto.dta") %>%
  mutate(length = length - mean(length))

lm1 <- lm(price ~ length, auto)
lm2 <- lm(price ~ length + weight + headroom + mpg, auto)
lm_aux <- lm(length ~ weight + headroom + mpg, auto)
auto <-
  auto %>%
  mutate(length_resid = residuals(lm_aux))

lm2_alt <- lm(price ~ length_resid, auto)

coef_lm1 <- lm1$coefficients
coef_lm2_alt <- lm2_alt$coefficients
resid_lm2 <- lm2$residuals

y_single <- tibble(price = coef_lm2_alt[1] + coef_lm1[2]*auto$length_resid,
                   length_resid = auto$length_resid)

y_multi <- tibble(price = coef_lm2_alt[1] + coef_lm2_alt[2]*auto$length_resid,
                  length_resid = auto$length_resid)

auto %>%
  ggplot(aes(x=length_resid, y = price)) +
  geom_point() +
  geom_smooth(data = y_multi, color = "blue") +
  geom_smooth(data = y_single, color = "red")
```

## Inferência

Como sabemos, inferência lida com a generalização da amostra para a população e, portanto, com a variabilidade inerente de amostra para amostra. Eu não vou revisar aqui os cálculos para derivar o erro padrão. Quero apenas enfatizar dois pontos que não são usualmente abordados em cursos de regressão. Em primeiro lugar, generalização da amostra para a população é diferente de generalização causal, também conhecida como validade externa. Esse ponto foi confundido por muitos autores, em particular o livro conhecido como KKV, e levou muitos pesquisadores a acreditarem que uma regressão possuía maior capacidade de generalização causal do que estudos de caso. Uma regressão (supondo que o erro padrão foi calculado corretamente) permite generalizar as estimativas para uma população. Porém, o que significa falar em generalização quando temos o universo de casos (por exemplo, todos os deputados, ou todos os candidatos, ou todos os municípios)? Quando temos o universo, não é diferente de estudos de caso que possuem todos os casos relevantes e, portanto, a noção de generalização da amostra para população não se aplica.

O que me leva ao segundo ponto: na inferência causal, em particular nesses casos em que temos o universo dos casos, ainda assim há incerteza. O trabalho de Abadie et. al (2020) discute a ideia de *design-based* inference. Nós vamos explicar no curso em mais detalhes o que é uma pesquisa *design-based* (em oposição a *model-based*). A ideia desse tipo de incerteza (e seu correspondente erro-padrão) é a seguinte. Imagine que estamos interessados em estimar o efeito causal da reeleição de prefeitos sobre a corrupção municipal. Suponha que tenho todos os municípios na amostra. Por fim, suponha que temos um experimento natural de forma que podemos supor que (talvez condicional a algumas variáveis) a reeleição é aleatória. Não há incerteza amostral para a população, mas há incerteza sobre o que aconteceria com a corrupção para os prefeitos reeleitos, caso não fossem reeleitos (e para os que perderam, como seria a corrupção caso fossem reeleitos). Em particular, se acreditamos que a reeleição foi aleatória, então uma nova rodada de amostragem (em um universo alternativo?) produziria outra configuração de prefeitos reeleitos e não-reeleitos e alguma variação na estimativa do efeito causal. Isso antecipa nossa discussão sobre causalidade da próxima aula, mas o ponto é que existe incerteza na variação do efeito causal, que não deriva de variação amostral propriamente, mas da aleatoriedade da intervenção.

Nas palavras dos autores: 

"it will be useful to distinguish between descriptive estimands, where uncertainty stems solely from not observing all units in the population of interest, and causal estimands, where the uncertainty stems, at least partially, from unobservability of some of the potential outcome" (p. 267). Meu ponto é que KKV e cia confundiram incerteza de estimandos descritivos com estimandos causais.

O que me leva de volta ao ponto anterior sobre a comparação entre estudos de caso e métodos quantitativos, quando o objetivo é inferência causal. A incerteza inerente é sobre o efeito da intervenção, não sobre variações amostrais. Além disso, em ambos os casos não sabemos (a princípio) se os estudos possuem validade externa, isto é, se os resultados valem para outras populações, no tempo e espaço. É preciso avançar nessa agenda, tanto em métodos quali como quanti. É um problema em aberto e que tem atraído muitas pesquisas novas, que não iremos cobrir no curso (até por desconhecimento meu de boa parte dessa literatura).


## Referências

Abadie, Alberto, Susan Athey, Guido W. Imbens, and Jeffrey M. Wooldridge. 2020. “Sampling-Based Versus Design-Based Uncertainty in Regression Analysis.” Econometrica 88 (0): 265–96.

<!--chapter:end:index.Rmd-->

# Resultados Potenciais

Durante muito tempo, inferência causal com regressão era caracterizada por recomendações vagas, ad hoc e inconsistências. O debate sobre o efeito causal do cigarro sobre câncer de pulmão é ilustrativo a esse respeito. Durante décadas, pesquisadores enfrentaram dificuldades para diferenciar correlação de causalidade em estudos epidemiológicos sobre tabagismo. Muitos estudos iniciais baseados apenas em correlação eram contestados por não apresentarem mecanismos claros ou critérios objetivos para validar inferências causais. Fisher (1958), por exemplo, questionou os resultados iniciais que ligavam o cigarro ao câncer por falta de critérios explícitos para identificar uma relação causal, argumentando que a correlação observada poderia decorrer de fatores confundidores, causalidade reversa ou problemas de mensuração.

A situação mudou gradualmente com contribuições metodológicas importantes, como os critérios de causalidade propostos por Hill (1965). Os critérios de Bradford Hill ofereceram uma lista explícita e sistemática para avaliar a plausibilidade causal em estudos observacionais:

1. O efeito deveria ser grande
2. reproduzível em estudos independentes
3. possuir uma relação monotônica com "dose" (isto é, aumento na dose não pode reduzir o efeito se o efeito é positivo e vice-versa se for negativo).
4. corresponde a um "experimento natural""
5. se comporta apropriadamente quando a causa é aplicada, removida e então reinstalada.
6. é consistente com o conhecimento especializado do tema
7. é, por exemplo, predita por alguma teoria bem estabelecida.

Nós temos amplas evidências de que muitas intervenções são causais, mesmo na ausência de qualquer experimento aleatório controlado. Sabemos, por exemplo, que defribilação, manobra de Heimlinch e uso de paraquedas são eficazes para prevenir mortes [@howick_etal_2009].

Em um artigo clássico dos primórdios da estatística escrito por Yule [@yule_1989], temos um dos primeiros exemplos de utilização da regressão para estudar o efeito causal do efeito de uma política (ajuda sobre pobreza). E a despeito do título do artigo falar em causalidade ("An investigation into the causes of changes in pauperism in england, chiefly during the last two intercensal decades"), a certa altura ele diz, em nota de rodapé, que "due to" deve ser lido como "associated to". Quase cem anos depois, o grande estatístico Cox afirmaria em um artigo sobre causalidade: "it is remarkable how relatively little causality is mentioned in the general statistics literature, except in a social science context"[@cox_1992, p. 292].

Exemplo da perspectiva de que falava Cox quando, por exemplo, @muthen_1987 chegou a afirmar que "It would be very healthy if more researchers abandon thinking of and using terms such as cause and effect" (p. 180). Algo ecoado em uma entrevista com um dos líderes da evolução causal desde os anos 70/80, Jamie Robins, que relata que seus papers (en journals de estatística) eram rejeitados por usar linguagem causal, algo rejeitado na época [@robins_2022]. Então parece bastante seguro dizer que a sensação geral na estatística até os anos 80 é que não se deveria usar linguagem causal fora de estudos experimentais, isto é, em estudos não-observacionais.

## Causalidade e o Método Comparativo

A ideia de causalidade é bastante presente na ciência política na literatura de polític comparada qualitativa. Empregando os métodos advogados por Stuart Mill, a ideia de causalidade sempre estive presente e associada a ideias de relações necessárias e ou suficientes. Nesse sentido, causalidade seria determiniística. A moderna forma de pensar causalidade abandona esse paradigma de relações necessárias e/ou suficientes, para pensar em termos de contrafactual, o que no fundo é próximo do que a pesquisa comparada fazia. Tomemos um exemplo clássico dessa literatura. [inserirautor] estava interessado em estudar o efeito ccausal de [inserir variável de tratamento] sobre [variável de resultado], e comparou [unidade de tratamento] com [unidade de controle].

## Potential Outcomes

Objetivos de aporendizado da aula:
Aprender a diferença entre esimando, estimador e estimativa.

Aprender as condições de identificação do ATE (Average Treatment Effect)



## Notação

Vamos assumir que existe um tratamento binário, que recebe o valor $1$ se a unidade $i$ recebe o tratamento, e $0$ caso contrário, dado por: $D_i \in \{1,0\}$. 

Suponha que eu tenha $N$ unidades que podem receber o tratamento ou controle. Então, o resultado potencial para a unidade $i$ é $Y_i(\mathbf{D})$, ou seja, o resultado (potencial) da unidade $i$ dado o conjunto de tratamento recebido por todas as $N$ unidades. Em outras palavras, o resultado potencial depende do status de tratamento de todas as unidades. O que nos leva à primeira suposição simplificadoras:

Assumption 1 (Stable Unit Treatment Value Assumption)
Se $D_i = D{'}_i$, então $Y_i(\mathbf{D}) = Y_i(\mathbf{D}^{'})$. Em palavras, se mudarmos o tratamento de $i$ de $D$ para $D'$, então o resultado potencial depende apenas dessa mudança, e não dos demais tratamentos. Ou seja, o resultado potencial depende apenas do próprio tratamento, não dos demais. Essa suposição també é chamada de não-interferência. Então podemos escrever o resultado potencial apenas como função de $D_i$: $Y_i(D_i)$.

Entretanto, os resultados potenciais não são observáveis. O que nós observamos é o resultado se a pessoa foi ou não tratada. O que nos leva à "switching equation":
$Y_i = Y_i(1)D_i + (1-D_i)Y_i(0)$

Podemos agora definir o efeito causal do tratamento ao nível da unidade: $\tau_i = Y_i(1) - Y_i(0)$

A switching equation conecta o observado aos resultados potenciais e vice-versa. Esse modelo é chamado de Modelo Causal de Neyman-Rubin.

## Problema Fundamental da Inferência Causal

Barizado por Holland (1986) de Problema Fundamental da Inferência Causal (PFIC) diz que não podemos observar, simultanemente, ambos os resultados potenciais $Y_i(1)$ e $Y_i(0)$.

Possívels soluções para o PFIC:

1. Assumir homogeneidade temporal (comparação antes de depois da mesma unidade)

2. Assumir homogeneidade da unidade (comparar dois indivíduos, um tratado, outro no controle)

3. Método estatístico (foco na esperança)

## Estimando

O que nós estamos interessados em estimar é o nosso **Estimando**.

Lundberg et al. (2021), definem de maneira bem completa o que é um estimando. Informalmente, é a quantidade causal que queremos estimar. Os autores separam o estimando teórico do estimando estatístico. O estimando teórico especifica a unidade teórica de interesse (ex.: o efeito de instituicões inclusivas sobre o desenvolvimento economômico do país $i$; "A Dilma teria sofrido impeachment se a lava-jato não existisse?"). O segundo componente é a população-alvo. Se formos agregar essa unidade, é sobre quem ou quê? No primeiro caso, é a categoria de países em desenvolvimento em 1990? Todos os países independentes do globo no seçulo XX? No segundo caso, é mais difícil pensar qual é a população alvo. Talv ez já seja a população e, nesse caso, nao cabe se perguntar sobre qume agregaríamos a quantidade. Ou talvez a pergunta de pesquisa seja sobre crises econômicas e impeachment, e o Brasil é só um caso. Daí a população alvo pode ser, talvez, países latino-americanos. Nesse caso, a pesquisadora deverá argumentar sobre como o estudo de caso é informativo sobre a população-alvo.

Estimando estatístico ou empírico é a quantidade que pode ser estimada estatisticamente (a princípio).

Estimativa: a aproximação do estimando usando uma amostra finita de dados
Estimador: o método ou fórmula para se chegar a uma estimativa para um estimando.

## Estimandos Mais Comuns

### ATE

Vamos definir o ATE e mostrar condições suficientes para identificação desse estimando.

O ATT é simplesmente o efeito causal médio entre todos os indivíduos de uma população. Às vezes chamado de PATE, de Populational Averate Treatment Effect.

Definição 2.1. Chamamos de ATE na população: 
$$\tau_{\text{ATE}} = \mathbb{E}[\tau_i] = \mathbb{E}[Y_i(1) - Y_i(0)] = \mathbb{E}[Y_i(1)] - \mathbb{E}[Y_i(0)]$$
O ATE nos dá o efeito do tratamento em toda a população de interesse.


### ATT

Definição 2.2. Chamamos de Average Treatment Effect on the Treated (ATT): 
$$\tau_{\text{ATT}} = \mathbb{E}[\tau_i|D_i=1] = \mathbb{E}[Y_i(1) - Y_i(0)|D_i=1] = \underbrace{\mathbb{E}[Y_i(1)|D_i=1]}_{\text{observado}} - \mathbb{E}[Y_i(0)|D_i=1]$$
Note que $\mathbb{E}[Y_i(1)|D_i=1]$ é um resultado potencial que podemos observar, já que é igual ao resultado realizado dos tratados. 

Esse estimando estima o efeito do tratamento apenas entre os tratados. Essa quantidade é, tipicamente, a mais relevante em políticas públicas. Considere a política pública de vacinação. O que é mais importante, saber o efeito causal da vacina em toda a população, ou em toda a população que tomaria a vacina (tratados)? Ou para dar um exemplo mais claro ainda. Não é relevante o efeito do bolsa-famnília sobre redução da pobreza em toda a população, nem mesmo se considerarmos que a população alvo é toda a população pobre. Pessoas que não vão participar do programa não importam muito. Importam as que efetivamente irão receber o programa.

### CATE

Vamos definir o Conditional Average Treatment Effect (CATE). Seja $X_i$ um conjunto de co-variáveis pré-determinadas (não causadas pelo tratamento). Então, podemos definir o CATE como:

$$\tau_{\text{CATE}} = \mathbb{E}[\tau_i|X_i=x] = \mathbb{E}[Y_i(1) - Y_i(0)|X_i=x] =  \mathbb{E}[Y_i(1) - \mathbb{E}[Y_i(1)|X_i=x]$$
Retornando ao nosso exemplo da introdução da urna eletrônica em um município sobre a pobreza municipal.
ATE: O efeito médio de um município ter urna eletrônica sobre a pobreza municipal comparado a voto em papel.
ATT: O efeito médio da urna eletrônica nos municípios que receberam urna eletrônica sobre a pobreza municial comparado a voto em papel.
CATE: O efeito médio de urna eletrônica sobre a pobreza municipal, em um determinado grupos de municípios (ex. do semiá-rido do Nordeste), comparado a voto em papel.

Se $X$ for discreto, podemos estabelecer a seguinte relação entre ATE e CATE:
$$\tau_{\text{ATE}} = \sum_{x \in X} \tau_{\text{CATE}}(x) p(X_i = x)$$
Há outros estimandos possíveis, mas esses são os mais comuns.

## Nota sobre estimandos

A rigor, podemos caracterizar ao nível da população dois contrastes: a distribuição de probabilidade de resultados potenciais do tratamento com a do controle, para um dado conjunto de covariáeis de pré-tratamento $\mathbf{X}$. Formalmente, sejam $f(Y(1)|\mathbf{X})$ e $f(Y(0)|\mathbf{X})$ as densidades dos dois resultados potenciais, então $f(Y(1)|\mathbf{X} - f(Y(0)|\mathbf{X})$ configura uma nova distribuição, da diferença entre os dois resultados potenciais. Nossa ênfase na esperança, portanto, é tanto uma questão de conveniência matemática quanto potencial interesse de pesquisa em um estimando em torno da média da diferença dessas duas distribuições, mas nada impede, a princípio, que estimarmos toda a distribuição da diferença.

Outra observação: como veremos mais para frente no curso, dados longitudinais não possuem estimandos claros. Alguns pesquisadores mais rigorosos em política comparada, por exemplo, falam em efeito de país-ano, pois esta é a unidade de análise e o estimando é definido nesse nível. Como veremos também mais para frente (e é um tema de pesquisa meu), também é complicado definir as condições de identificação em dados longitudinais. Voltaremos a isso.

## Exercício - Qual o estimando e o estimador (se possível)?
Abstract 1

```{r abstract1, message=FALSE, echo=FALSE}
library(here)
invisible(here())
knitr::include_graphics(here("imagens", "abstract-campaign-finance.png"))
```

Abstract 2

```{r abstract2, echo=FALSE}
knitr::include_graphics(here("imagens", "abstract-corruption.png"))
```

Abstract 3

```{r abstract3, echo=FALSE}
knitr::include_graphics(here("imagens", "abstract-rural.png"))
```

## Identificação

"Econometric identification really means just one thing: model parameters or features being uniquely determined from the observable population that generates the data"(Lwebel, apud Paul GP). Ou seja, se você tiver acesso a uma amostra infinita, isto é, não há problemas inferenciais de amostra pequena, é possível estimar precisamente o parâmetro de interesse? Dizemos que, nesse caso, o estimando é identificável.

O que seria um estimando não-identificável? Digamos que estou interessado em estimar o efeito causal da segunda dose de uma vacina sobre internação por uma doença. Para a pessoa receber a segunda dose, obviamente ela precisa receber a primeira. Suponha que a primeira dose ajuda a reduzir a internação. É impossível estimar o efeito causal da segunda dose.

Para mostrar que o ATE é identificado, vamos supor o que chamamos de ignorabilidade forte (strong ignorability). 

Definição. Dizemos que $D_i$ é fortemente ignorável condicional a um vetor $\mathbf{X_i}$ se:
1. $Y_i(1), Y_i(0) \perp D_i$
2. $\exists \epsilon > 0 \text{ tal que } \epsilon < Pr(D_i = 1 | \mathbf{X_i}) < 1 - \epsilon$

Em palavras, a primeira condição diz que os resultados potenciais são independentes de receber ou não o tratamento. Quando pensamos em modelos com seres humanos ou unidades com agência, a principal preocupação é que as unidades não se auto-selecionam no tratamento que lhes é mais benéfico (ou que acreditam sê-lo). Às vezes na literatura essa condição aparece como permutabilidade (exchangeability): Como dizem Hernan e Robins em seu livro, "the treated and the untreated are exchangeable because the treated, had they remained untreated, would have experienced the same average outcome as the untreated did, and vice versa."(p. 29).

A segunda condição, conhecida como *commmon support* ou *overlaping condition*, diz que não existe unidade que não possa receber o tratamento ou controle. Essa condição é mais forte do que a positividade (toda unidade tem probabilidade positiva de receber o tratamento).

Quero explorar aqui essa condição por meio de uma simulação. Vamos supor que um efeito causal $\tau_i$ tem distribuição normal com média $2$ e desvio-padrão $2$. E vamos supor que pessoas com $\tau_i >6$ não podem receber o tratatamento, apenas o controle. Veremos que o efeito causal para esse subgrupo não é identificado e mesmo o ATE não é identificado.

```{r common support, echo=FALSE}

set.seed(1234)
n <- 10000
tau <- rnorm(n, 2, 2)
y_0 <- rnorm(n, 0, 2) # resultados potenciais do controle
y_1 <- tau + y_0 # resultados potenciais do tratamento
d <- rbinom(n, 1, .5) # tratamento ou controle
# violação de common suuport

d1 <- ifelse(y_1 > 6, 0, d)
table(d, d1)

y <- y_1*d + y_0*(1-d)
(ate <- mean(y[d==1]) - mean(y[d==0]))

y_bias <- y_1*d1 + y_0*(1-d1)
(ate_bias <- mean(y_bias[d1==1]) - mean(y_bias[d1==0]))


```

Um último comentário: ignorability às vezes aparece como "tratamento é exógeno". Porém, exogeneidade ignora a segunda condição e trata apenas da primeira. Em uma audiência de ciência política, dizemos que o tratamento é condicionalmente aleatório ou exógeno (o que é impreciso).

## Identificação do ATE

Teorema 1: Se $D_i$ é fortemente ignorável condicional a $\mathbf{X_i}$, então:
$$\mathbb{E}[\tau_i] = \sum_{x \in X}(\mathbb{E}[(Y_i|D_i=1, \mathbf{X_i} = x)] - \mathbb{E}[(Y_i|D_i=0, \mathbf{X_i} = x)])Pr(\mathbf{X_i = x})$$
Prova: O ATE foi definido como:
$$\mathbb{E}[\tau_{\text{ATE}}] = \mathbb{E}[\tau_i] = \mathbb{E}[Y_i(1)] - \mathbb{E}[Y_i(0)]$$
Pela LIE, temos que:
$$\mathbb{E}[Y_i(1)] = \mathbb{E}[\mathbb{E}[Y_i(1)|\mathbf{X_i}]$$
$$\mathbb{E}[Y_i(0)] = \mathbb{E}[\mathbb{E}[Y_i(0)|\mathbf{X_i}]$$ 

Com ignorabilidade forte, $\mathbb{E}[(Y_i(0)|\mathbf{X_i}] = \mathbb{E}[Y_i(0)|D_i=0, \mathbf{X_i}] = \mathbb{E}[Y_i|D_i=0, \mathbf{X_i}]$. Similarmente, $\mathbb{E}[(Y_i(1)|\mathbf{X_i}] = \mathbb{E}[Y_i(1)|D_i=1, \mathbf{X_i}] = \mathbb{E}[Y_i|D_i=1, \mathbf{X_i}]$. Juntando tudo, chegamos à proposição do teorema.

Ou seja, com ignorabilidade forte, podemos estimar o ATE não-parametricamente apenas a partir de observáveis. O CATE também é identificado, como corolário.

## Equações estruturais

Normalmente nós temos um modelo que queremos estimar o efeito causal, e não algo sobre o mecanismo de assignment do tratamento. Vamos conectar as duas abordagens.

Seja o modelo: $Y_i = \alpha + \beta D_i + \epsilon_i$. Nós intrepretamos $\beta$ como a diferença média no $y$ de uma unidade no tratamento, formalmente:
$\mathbb{E}[Y|D_i=1] - \mathbb{E}[Y|D_i=0] = \mathbb{E}[\alpha + \beta D_i + \epsilon_i|D_i=1] - \mathbb{E}[\alpha + \beta D_i + \epsilon_i|D_i=0] = \beta + \mathbb{E}[\epsilon_i|D_i=1] - \mathbb{E}[\epsilon_i|D_i=0]$.
E dizemos que, sob a suposição de esperança condicional zero do erro, ou seja, $\mathbb{E}[\epsilon_i|D_i=1] = \mathbb{E}[\epsilon_i|D_i=0] = 0$. Portanto, temos que $\mathbb{E}[Y|D_i=1] - \mathbb{E}[Y|D_i=0] = \beta$. E o estimador de MQO é não-viesado.

E de forma geral, temos que $\mathbb{E}[Y|D_i] = \alpha + \beta$, sob a suposição de esperança condicional zero do erro.

Vamos mapeá-lo ao modelo de resultados potenciais com a *switching equation*.

$$
\begin{aligned}
Y_i &= Y_i(0)(1-D_i) + Y_i(1)D_i \\
&= Y_i(0) + \tau_i D_i \\
&= Y_i(0) + \tau_i D_i + \tau D_i - \tau D_i\\
&= Y_i(0) + \tau D_i + (\tau_i - \tau)D_i \\
&= \mathbb{E}[Y_i(0)|D_i=0] - \mathbb{E}[Y_i(0)|D_i=0] + Y_i(0) + \tau D_i + (\tau_i - \tau)D_i \\
&= \underbrace{\mathbb{E}[Y_i(0)|D_i=0]}_{\alpha} + \underbrace{\tau}_{\beta} D_i + \underbrace{(\tau_i - \tau)D_i + (Y_i(0) - \mathbb{E}[Y_i(0)|D_i=0])}_{\epsilon_i} \\
\end{aligned}
$$
Nós sabemos que em uma regressão estamos estimando $\mathbb{E}[Y_i|D_i]$. Podemos agora ver com clareza o que de fato estamos estimamos em termos causais.

$$
\begin{aligned}
\mathbb{E}[Y_i|D_i=1] &= \alpha + \tau + \mathbb{E}[\epsilon_i|D_i=1] \\
\mathbb{E}[Y_i|D_i=0] &= \alpha + \mathbb{E}[\epsilon_i|D_i=0] \\
\mathbb{E}[\epsilon_i|D_i=1]  &=  \mathbb{E}[(\tau_i - \tau)D_i + (Y_i(0) - \mathbb{E}[Y_i(0)|D_i=0])|D_i=1] \\
&=  \mathbb{E}[(\tau_i - \tau)D_i|D_i=1] + \mathbb{E}[(Y_i(0) - \mathbb{E}[Y_i(0)|D_i=0])|D_i=1] \\
&=  \mathbb{E}[\tau_i D_i|D_i=1] -\tau\mathbb{E}[ D_i|D_i=1] + \mathbb{E}[Y_i(0)|D_i=1] - \mathbb{E}[\mathbb{E}[Y_i(0)|D_i=0]|D_i=1] \\
&=  (\mathbb{E}[\tau_i|D_i=1] -\tau) + \mathbb{E}[Y_i(0)|D_i=1] - \mathbb{E}[Y_i(0)|D_i=0] \\
\mathbb{E}[\epsilon_i|D_i=0]  &=  \mathbb{E}[(\tau_i - \tau)D_i + (Y_i(0) - \mathbb{E}[Y_i(0)|D_i=0])|D_i=1] \\
&= \mathbb{E}[Y_i(0)|D_i=0] - \mathbb{E}[\mathbb{E}[Y_i(0)|D_i=0]|D_i=0] \\
&= 0
\end{aligned}
$$

Portanto, $\mathbb{E}[Y_i|D_i=1] - \mathbb{E}[Y_i|D_i=0] = \tau + (\mathbb{E}[\tau_i|D_i=1] -\tau) + \mathbb{E}[Y_i(0)|D_i=1] - \mathbb{E}[Y_i(0)|D_i=0]$
Em palavras, estimamos o efeito causal médio, $\tau$, mais um componente que tem a ver com os efeitos causais heterogêneos mais um componente que é a diferença no resultado potencial do controle entre os tratados e o controle. Se $\mathbb{E}[Y_i(0)|D_i=1] - \mathbb{E}[Y_i(0)|D_i=0] \neq 0$, o efeito estimado é viesado. Similarmente, se $\mathbb{E}[\tau_i|D_i=1] \neq \tau$, também teremos viés, ou seja, se o efeito causal dos tratados for diferente do efeito médio da população, também temos uma estimativa viesada do ATE. Porém, nesse caso, note que estamos viesando para estimar o efeito médio dos tratados, que é o ATT. Para ver isso, suponha que não há diferença nos resultados potenciais de não receber o tratamento entre os tratados e os no grupo controle, de modo que $\mathbb{E}[Y_i(0)|D_i=1] - \mathbb{E}[Y_i(0)|D_i=0] = \tau + (\mathbb{E}[\tau_i|D_i=1] -\tau)  = \mathbb{E}[\tau_i|D_i=1]$, que é o ATT.

## Modelo versus Desenho

Há na literatura (mais de economia) uma distinção entre estimando baseado em modelos e baseado em designs (desenho). 

Model-based: O estimando é identificado a partir de um modelo dos resultados potenciais, condicional ao tratamento e co-variáveis. O exemplo arquetípico é modelo de diferença em diferenças ou controle sintético, em que estimamos o efeito causal a partir de estimativa do contrafactual a partir de dados observados.

Design-based: O estimando é identificado a partir de suposições sobre o mecanismo de atribuição do tratamento e co-variáveis. O exemplo arquetípico desse tipo de pesquisa é o experimento aleatório controlado.

## Exercício em sala
Na década de 1970, houve um programa de treinamento e emprego conhecido como National Supported Work (NSW). Este programa temporário visava ajudar trabalhadores desfavorecidos e sem habilidades básicas a ingressarem no mercado de trabalho, oferecendo experiência profissional e orientação em um ambiente protegido. Um aspecto inovador do NSW foi a seleção aleatória de candidatos qualificados para os treinamentos, garantindo que o grupo de tratamento recebesse todos os benefícios do programa, enquanto o grupo de controle não tinha suporte.

Os participantes do grupo de tratamento tinham emprego garantido por 9 a 18 meses, dependendo do grupo-alvo e do local. Eles trabalhavam em equipes de 3 a 5 pessoas, reunindo-se frequentemente com um orientador para discutir questões do programa e desempenho. Embora recebessem salários inferiores aos de um emprego regular, havia possibilidade de aumento conforme o desempenho e a frequência. Ao término do período, os participantes precisavam procurar emprego regular. O programa também coletou dados de renda e informações demográficas de ambos os grupos, realizando entrevistas periódicas, o que gerou diferentes tamanhos de amostra entre os estudos. O NSW utilizava um desenho experimental aleatório.

Lalonde (1986) comparou os resultados experimentais com dados observacionais. Para isso, substituiu os dados do grupo controle atribuídos aleatoriamente, com dados de três amostras do Current Population Survey (CPS) e do Panel Survey of Income Dynamics (PSID). E usou as técnicas econométricas usuais para isso. O resultado não foi bom para a econometria. Voltaremos a isso mais pra frente. Por hora, vamos estimar efeitos causais com os dados experimentais.

O exercício a seguir é adaptado do exercício disponibilizado por Paul GP em seu github, no seu curso de métodos.

Esta análise utilizará a amostra de Dehejia e Wahba do conjunto de dados Lalonde do experimento NSW. O conjunto de dados é "lalonde nsw.csv". A variável de resultado é "re78" (rendimento real em 1978). O indicador de tratamento é "treat". As demais variáveis são potenciais covariáveis. Para os fins deste conjunto de problemas, assuma que "treat" é atribuído de forma aleatória.

(a) Calcule o efeito médio do tratamento da política, $\mathbb{E}[\tau_i]$, utilizando uma simples diferença de médias.

(b) Calcule o efeito médio do tratamento sobre os tratados da política, $\mathbb{E}[\tau_i|treat=1]$. Como ele se compara à parte (a)?


```{r Lalonde, echo=FALSE}
library(here)
library(data.table)
nsw <- fread(here("Dados", "lalonde_nsw.csv"))

# a
ate <- sum(nsw$re78*nsw$treat)/sum(nsw$treat) - sum(nsw$re78*(1-nsw$treat))/sum(1-nsw$treat)
ate
ate_aux <- nsw %>% group_by(treat) %>% summarise(media = mean(re78))
ate_aux$media[2] - ate_aux$media[1]

# b
#ATT é o ATE com aleatorização (ignorability forte).

# c

```

## Referências

Lalonde, Robert. 1986. “Evaluating the Econometric Evaluations of Training Programs with Experimental Data.” American Economic Review 76 (4): 604–20.

Rajeev Dehejia and Sadek Wahba, "Causal Effects in Non-Experimental Studies: Reevaluating the Evaluation of Training Programs," Journal of the American Statistical Association, Vol. 94, No. 448 (December 1999), pp. 1053-1062.

Rajeev Dehejia and Sadek Wahba, "Propensity Score Matching Methods for Non-Experimental Causal Studies," Review of Economics and Statistics, Vol. 84, (February 2002), pp. 151-161.

Robert Lalonde, "Evaluating the Econometric Evaluations of Training Programs," American Economic Review, Vol. 76 (1986), pp. 604-620.

Lundberg, I., Johnson, R., & Stewart, B. M. (2021). What is your estimand? Defining the target quantity connects statistical evidence to theory. American Sociological Review, 86(3), 532-565.

Paul W Holland. Statistics and causal inference. Journal of the American statistical Association, 81(396):945–960, 1986.

<!--chapter:end:02-PO.Rmd-->

# DAGs

## Causalidade

![Fonte: xkcd](https://imgs.xkcd.com/comics/correlation.png) <!-- Substitua path/to/your/image.jpg pelo caminho da imagem XKCD sobre causalidade -->

## Introdução

Uma das principais abordagens para fazer inferência causal utiliza diagramas causais chamados de Directed Acyclic Graphs (DAG). Ela foi desenvolvida na ciência da computação entre os anos 80 e 90 e é associada com o trabalho pioneiro de Judea Pearl. Veja o livro *The Book of Why* para uma história de como surgiu essa abordagem.

Abaixo temos um exemplo simples de um DAG:

```{r dag1, echo=FALSE, message=FALSE}
library(ggdag)
dag <- dagify(y ~ x, y ~ z)

ggdag(dag)
```
Eles são chamados de DAGs porque os gráficos são direcionados (apontam em uma direção), acyclic porque não permitem ciclos (isto é, se A causa B, B não pode causar A) e graphs porque, como você pode imaginar, são grafos.

No exemplo acima, o DAG é formado por três variáveis \{y, x, z\} que são, em geral, variáveis aleatórias. E as flechas indicam direção de causalidade. Ou seja, $x$ causa $y$ e $z$ causa $x$. É importante saber que DAGs são não paramétricos. Eles podem ser interpretados como: $y = f(x, z)$. Ou seja, qualquer função de x e z são igualmente possíveis. Eis alguns exemplos compatíveis com o DAG acima:

- $y = x + z$
- $y = 10 + x + z + x*z$
- $y = 3*x^z$
- $y = \pi*z/x + x^2 + 1/(z^3)$

A razão porque não escrevemos DAGs como equações é porque $y = f(x, z)$ não expressa adequadamente a relação de causalidade pois, em matemática, é indiferente escrever $f(x, z) = y$ ou $y = f(z, x)$. Porém, dizer que $x$ e $z$ causam $y$ é muito diferente de dizer que $y$ causa $x$ e $z$. E com o DAG as flechas indicam a direção da causalidade.

## Os Tipos Básicos de DAGs

### 1. Chains

Em uma *chain*, _x_ causa _w_ que, por sua vez, causa _y_. Aqui, _w_ pode ser considerado o mediador do efeito de _x_ sobre _y_.  
**Exemplo:** O desempenho econômico de um país pode aumentar a popularidade do presidente, o que leva a mais votos.  
Representação:  
```{r chain, echo=FALSE, message=FALSE}
library(ggdag)
dag <- dagify(w ~ x, y ~ w)

ggdag(dag)
```

### 2. Forks

Em um *fork*, uma variável _w_ causa ambos _x_ e _y_. Dessa forma, _w_ é uma causa comum que pode gerar correlação espúria entre _x_ e _y_.  
**Exemplo:** A qualidade de um candidato pode fazer com que ele arrecade mais dinheiro para a campanha e, ao mesmo tempo, obtenha mais votos.  
Representação:  

```{r fork, echo=FALSE, message=FALSE}
library(ggdag)
dag <- dagify(x ~ w, y ~ w)

ggdag(dag)
```


### 3. Colliders

Em um *collider*, _x_ causa _w_ e _y_ também causa _w_. Esse tipo de estrutura é também chamado de "fork invertido". Apesar de _x_ e _y_ não terem relação causal direta, controlar para _w_ (ou um de seus descendentes) pode introduzir uma correlação espúria entre _x_ e _y_.  
```{r collider, echo=FALSE, message=FALSE}
library(ggdag)
dag <- dagify(w ~ x, w ~ y)

ggdag(dag)
```

**Exemplo:** Imagine que você organiza uma festa e convida apenas pessoas que fazem ciência política ou são canhotas. Na população geral pode não haver relação entre essas características, mas na festa pode surgir uma correlação: se uma pessoa é canhota, ela pode ter maior probabilidade de fazer ciência política.

```{r collider1, echo=FALSE, message=FALSE}
library(ggdag)
dag <- dagify(festa ~ canhota, festa ~ CP)

ggdag(dag)
```

## Simulação no R: Ilustrando o Collider Bias

Vamos rodar uma simulação para ilustrar o collider bias. Suponha que 10% das pessoas fazem ciência política e 5% são canhotas.

```{r}
library(dplyr)
set.seed(4)

# Gerando as variáveis
cp <- rbinom(1000, 1, p = 0.1)      # 10% fazem ciência política
canhoto <- rbinom(1000, 1, p = 0.05)  # 5% são canhotos

# Definindo a condição da festa: convida se faz ciência política ou é canhoto
festa <- ifelse(cp == 1, 1, ifelse(canhoto == 1, 1, 0))
tabela <- data.frame(cp, canhoto, festa)

# Correlação na população geral
cor_geral <- round(cor(cp, canhoto), 2)
print(cor_geral)

# Correlação entre os que foram à festa
cor_festa <- tabela %>%
  filter(festa == 1) %>%
  summarise(cor = round(cor(cp, canhoto), 2))
print(cor_festa)
```

Na população em geral, a correlação é próxima de zero (aproximadamente -0,02). Porém, entre as pessoas que foram à festa, a correlação pode chegar a -0,95, evidenciando como condicionar em um collider (neste caso, a variável festa) pode induzir correlação espúria.

## Definições

**Path (caminho)**: É uma sequência de flechas conectadas.
Um **directed path** (caminho dirigido) é aquele em que todas as flechas seguem a mesma direção (por exemplo, \( x \to z \to y \)).

### Relações entre Variáveis (nós):
As relações são descritas usando termos da genética, como pais, filhos, ancestrais, descendentes e vizinhos.
Pais e filhos referem-se a relações diretas.
Ancestrais e descendentes incluem todas as variáveis em qualquer posição no caminho.

Um path sem collider está aberto; um path com collider está fechado.

Duas variáveis (ou conjuntos) estão **d-separated** se não houver caminho aberto entre elas. Caso contrário, podem ou não ser independentes, pois múltiplos caminhos abertos podem se cancelar.

## Controle e Ajuste

No contexto dos DAGs, controlar para variáveis pode ter diferentes significados:

Experimentos: Controlar significa manipular o valor da variável pelo pesquisador.
Exemplo: Um experimento em que o resultado do lançamento de uma moeda determina se um pedido de acesso à informação será feito por um homem ou mulher.

```{r moeda, echo=FALSE, message=FALSE}

dag <- dagify(genero ~ moeda, LAI ~ genero)

ggdag(dag)
```

Estudos Observacionais: Controlar significa condicionar (estratificar ou incluir em uma regressão). Para visualizar isso em um DAG, considere o seguinte DAG:

```{r controle-base, echo=FALSE, message=FALSE}

dag <- dagify(g ~ c + u, c ~a + b, e ~a + c, d ~b + c)

ggdag(dag)
```

Controlar para C, nesse DAG, significa efetuar os seguintes passos, na sequência: 
1. Eliminar todas as flechas que saem de C. 
```{r controle-C1, echo=FALSE, message=FALSE}

dag <- dagify(g ~u , c ~a + b, e ~a , d ~b )

ggdag(dag)
```

2. Se C for um collider, elimine as flechas que vão para C e conecte os parentes de C por meio de linhas tracejadas. 

```{r controle-C2, echo=FALSE, message=FALSE}

dag <- dagify(g ~u ,  a ~~ d, e ~a , d ~b )

ggdag(dag)
```

3. elimine C
```{r controle-C3, echo=FALSE, message=FALSE}

dag <- dagify(g ~u ,  a ~~ d, e ~a , d ~b )

ggdag(dag)
```

Manipular: Determinar o valor da variável.


Alterar o Gráfico:


Para controlar a variável G (por exemplo, se relacionada a C):
Eliminar as flechas que saem de G.
Eliminar as flechas do collider (no caso, c e u, parentes de G) e criar relação bi-direcional espúria.
Remover G do gráfico.





Em resumo, se C depende de A e B de forma independente, condicionar em C pode criar uma relação espúria entre A e B. Por exemplo, se A e B são binárias e \( C = A + B \), para \( C = 1 \) saber o valor de A determina automaticamente o valor de B, e vice-versa.

De modo geral, condicionar em um collider inverte o status dos caminhos: caminhos que estavam abertos podem se fechar e vice-versa. Além disso, condicionar em um descendente de um collider também pode alterar os efeitos, atenuando ou abrindo caminhos que originalmente estavam fechados.

## Fatorização da Probabilidade Conjunta

Toda distribuição de probabilidade obedece à regra da cadeia de probabilidades (nenhuma suposição adicional).

Lembremos: 

$Pr(X,Y) =  Pr(Y|X) Pr(X) = Pr(X|Y) Pr(Y)$

Similarmente,

$Pr(X,Y,Z) =  Pr(Y|X,Z) Pr(X|Z) Pr(Z) = Pr(X|Y,Z) Pr(Y|Z) Pr(Z) = Pr(Z|Y,X) Pr(X|Y) Pr(X) = \cdots$

De maneira geral, se temos $n$ variáveis marginais, temos no total $n!$ maneiras distintas de fatorar a distribuição conjunta. A lógica é assim>

Seja uma pmf conjunta $Pr(x_1, x_2, ..., x_k)$. Então, podemos usar a regra do produto:

$Pr(x_1, x_2, ..., x_k) = Pr(x_1) Pr(x_2, ..., x_k|x_1)$

Aplicando a regra iterativamente, $Pr(x_2, ..., x_k|x_1) = Pr(x_2|x_1)Pr(x_3, ..., x_k|x_1, x_2)$, de forma que:
$Pr(x_1, x_2, ..., x_k) = Pr(x_1) Pr(x_2|x_1)Pr(x_3, ..., x_k|x_1, x_2)$
E assim por diante, até:
$Pr(x_1, x_2, ..., x_k) = Pr(x_1) Pr(x_2|x_1) Pr(x_3| x_2, x_1) \cdots Pr(x_k|x_1, x_2, x_3, ... , x_{k-1})$

A Regra do produto pode ser aplicada em qualquer ordem, gerando fatorizações distintas.

## Fatorização e DAGs

Existem teoremas que mostram que existe uma relação entre DAGs e fatorização de probabilidades conjuntas. Dado um DAG, em que um nós é independente condicional a outro nó, isso implica a fatorização da probabilidade conjunta de acordo com essa relação, e vice-versa. Dois exemplos abaixo ilustram essa propriedade.

Considere o DAG abaixo:

```{r fatorizacao, echo=FALSE, message=FALSE}

dag <- dagify(Y ~ X ,  X ~ Z + W, Z ~ M, W ~ M )

ggdag(dag)
```

Nós sabemos que, condicional a X, Y é independente de Z, W e M. Similarmente, X é independente de M, condicional a Z e W. Podemos então fatorar a distribuição conjunta da seguinte maneira:

$$Pr(M, W, X, X, Y) = Pr(M) Pr(Z|M) Pr(W|M) Pr(X|W,Z) Pr(Y|X)$$

Ou seja, basta escrever a probabilidade condicional nas variáveis que tornam cada nós independente para descrever a distribuição de probabilidade conjunta.

## Fatorização, DAGs e Causalidade

De volta à causalidade, um DAG em que não há confouding, isto é, sem back-door aberto, como o DAG abaixo, implica que a fatorização observacional é igual à fatorização intervencional:

```{r fatorizacao1, echo=FALSE, message=FALSE}

dag <- dagify(Y ~ X  )

ggdag(dag)
```

$$Pr(Y = y |do (X = x)) = Pr(Y|X)$$
Logo, é verdade que 
$$Pr(Y,X) = P(X)Pr(Y|X) = Pr(X)Pr(Y = y |do (X = x))$$.

O operador "do" aqui é uma inovação do Pearl, e diz que fizemos uma cirurgia no gráfico e determinamos, exogenamente, por assim dizer, que o valro de $X$ é $x$.



Referências

Hernán MA, Robins JM (2019). Causal Inference. Boca Raton: Chapman & Hall/CRC. Disponível temporariamente em: https://www.hsph.harvard.edu/miguel-hernan/causal-inference-book/
Greenland, S., & Pearl, J. (2014). Causal diagrams. Wiley StatsRef: Statistics Reference Online, 1-10.

<!--chapter:end:03-DAGs.Rmd-->

# Experimentos


## Introdução

- Um experimento é o desenho de pesquisa no qual a pesquisadora controla o mecanismo de atribuição do tratamento e controle
- Seja $p_i = P(T_i=1)$. Então $p_i$ é conhecido e controlado pela pesquisadora.
- Em contraposição, um estudo observacional é quando a pesquisadora não controla o mecanismo (natureza ou realidade social)
- Quando uma quantidade potencial (estimando) pode ser descrita em função da distribuição de dados observáveis, dizemos que o estimando é identificável. De outro modo, não identificado.
- Veremos porque experimentos produzem desenhos críveis de identificação causal
- Vamos supor experimentos ideais (sem attrition ou non-compliance)

Nós já vimos que uma suposição crítica é a SUTVA.

- Stable Unit Treatment Values Assumption
- Não interferência e sem varição escondida no tratamento
  - PO não varia com o tratamento atribuiído a outra unidades
  - PO de uma unidade não é impactado pelo nível de tratamento de outras unidades
- Para cada unidade, não há formas distintas ou versões de cada nível de tratamento
- Definição não-ambígua do tratamento

- Supondo SUTVA, Diferença Simples de Média pode ser decomposta em ATE + viés de seleção
- $\underbrace{\mathbb{E}[Y_i|T_i=1] - \mathbb{E}[Y_i|T_i=0]}_{\text{Simple Difference in Outcomes (SDO)}} = \mathbb{E}[Y_i^1|T_i=1] - \mathbb{E}[Y_i^0|T_i=0]$
- Podemos adicionar e subtrair os resultados contrafactuais para os tratados
- $= \mathbb{E}[Y_i^1|T_i=1] - \color{blue}{\mathbb{E}[Y_i^0|T_i=1]} + \color{red}{\mathbb{E}[Y_i^0|T_i=1]} - \mathbb{E}[Y_i^0|T_i=0]$
- $= \underbrace{\mathbb{E}[Y_i^1 - Y_i^0|T_i=1]}_{\text{ATT}} + \underbrace{\mathbb{E}[Y_i^0|T_i=1] - \mathbb{E}[Y_i^0|T_i=0]}_{\text{Viés de Seleção}}$

## Experimentos aleatórios

- Mecanismo de atribuição de tratamento é probabilístico (Positividade): $0 < p_i < 1$.
- Unconfoundedness ou Permutabilidade (ou *assignment mechanism–ignorability*): $P(T_i=1|y^1, y^0) = P(T_i)$.

O que é Permutabilidade (uncounfoudedness)?

- A distribuição dos resultados potenciais é independente do tratamento.
- $\mathbb{E}[Y^1|T=1] = \mathbb{E}[Y^1|T=0]$
- $\mathbb{E}[Y^0|T=1] = \mathbb{E}[Y^0|T=0]$
- Resultados potenciais são independentes do tratamento, dadas as covariáveis.
- Se a condição de tratamento fosse hipoteticamente trocada, os resultados esperados permaneceriam os mesmos.
- Isso significa que em um experimento com permutabilidade, não temos viés de seleção (Por quê?).

- Independência entre tratamento e resultados potenciais implica que $\mathbb{E}[Y^0_i|T_i=1] = \mathbb{E}[Y^0_i|T_i=0] = \mathbb{E}[Y^0_i]$
- Portanto, o viés de seleção, dado por $\mathbb{E}[Y_i^0|T_i=1] - \mathbb{E}[Y_i^0|T_i=0]$, fica:
- $\mathbb{E}[Y_i^0|T_i=1] - \mathbb{E}[Y_i^0|T_i=0] = \mathbb{E}[Y_i^0] - \mathbb{E}[Y_i^0] = 0$
- Ou seja, SDO estima o ATE (via ATT).
- $\underbrace{\mathbb{E}[Y_i|T_i=1] - \mathbb{E}[Y_i|T_i=0]}_{\text{Simple Difference in Outcomes (SDO)}} =  \underbrace{\mathbb{E}[Y_i^1 - Y_i^0|T_i=1]}_{\text{ATT}} = ATE$


## Restrição de Exclusão

- Formalmente, podemos separar a alocação do tratamento e o tratamento efetivamente recebido. Seja $Z_i$ a alocação do tratamento e $T_i$ o tratamento recebido.
- Então, a restrição de exclusão quer dizer que o que importa é o tratamento efetivamente recebido $T_i$, e não a variável que aloca o tratamento $Z_i$.
- Formalmente, isso quer dizer que: $Y^{1,z=1, T}_i = Y^{1,z=0, T}_i = Y^{1,T}_i$ e similarmente, $Y^{0,z=0,T}_i = Y^{0,z=0,T}_i = Y^{0,T}_i$
- Quando não ocorre isso? Se o mecanismo de atribuição do tratamento dispara outras causas
- Suponha que um experimento é sobre efeito de transferência de dinheiro em bem-estar
- Se ongs, sabendo do experimento, forem ajudar quem não tiver sido alocado para receber dinheiro

- Se houver erro de mensuração assimétrico?
- Pesquisadores distintos entrevistam recipientes e não-recipientes da transferência de dinheiro, com habilidades distintas
- Ou questionários diferentes. Erro de mensuração assimétrico

- Nova *switching equation*.
- Seja $e_{i1}$ o erro de mensuração cometido se uma observação é atribuída para o tratamento, e, analogamente, $e_{i0}$ o erro para o controle.
- De $Y_i = T_iY^1_i + (1- T_i)Y^0_i$ para $Y_i = T_i(Y^1_i + e_{i1}) + (1- T_i))(Y^0_i + e_{i0})$. 
- Novo SDO: $\mathbb{E}[Y_i|T_i=1] - \mathbb{E}[Y_i|T_i=0] = \mathbb{E}[Y^1_i + e_{i1}|T_i=1] - \mathbb{E}[Y^0_i + e_{i0}|T_i=0] = \mathbb{E}[Y^1_i|T_i=1] + \mathbb{E}[e_{i1}|T_i=1] - \mathbb{E}[Y^0_i|T_i=0] - \mathbb{E}[e_{i0}|T_i=0]$
- Novo SDO pode se rearranjado: $\underbrace{\mathbb{E}[Y^1_i|T_i=1] - \mathbb{E}[Y^0_i|T_i=0]}_{\text{antigo SDO}} + \underbrace{\mathbb{E}[e_{i1}|T_i=1]  - \mathbb{E}[e_{i0}|T_i=0]}_{\text{Dif média no erro de mensuração}}$
- Se $\mathbb{E}[e_{i1}|T_i=1] \neq \mathbb{E}[e_{i0}|T_i=0]$, então SDO será viesado.

Como Garantir a restrição de Exclusão?

- Double blindness (duplo cego)
- Paralelismo na administração do experimento (mesmo questionário e mesmos entrevistadores)
- Na pior das hipóteses, aleatorização dos entrevistadores.

## Tipos de experimentos

### Aleatorização de Bernoulli 

- É o experimento com aleatorização simples (basicamente, lançamento de moeda)
- Matematicamente, $p_i(T_i=1) = p$.
- Problema: Possível "má aleratorização" (todo mundo no controle ou tratamento)
- ps.: toda aleatorização realizada é matematicamente equivalente.
- Possui $2^n$ configurações possíveis de alocação entre tratamento e controle


```{r echo=TRUE, eval=FALSE}
set.seed(10)
n <- 50
hist(replicate(1000, sum(rbinom(n, 1, 0.5))), 
     main = "aleatorização de Bernoulli",
     xlab = "Número de tratados",
     col = "lightblue") + xlim(0,50)
```


```{r echo=FALSE, eval=TRUE}
set.seed(10)
n <- 50
hist(replicate(1000, sum(rbinom(n, 1, 0.5))), 
     main = "aleatorização de Bernoulli",
     xlab = "Número de tratados",
     col = "lightblue",
     xlim = c(10,40))
```

### Aleatorização Completa

- Seleciono aleatoriamente um número fixo de pessoas para tratamento e controle
- Ex.: 25 para tratamento e 25 para controle
- Basta numerar cada unidade (de 1 a 50) e amostrar 25 aleatoriamente para tratamento (e restante para controle)
- Vantagem: garanto número de obs em cada condição
- Possui ${N \choose \frac{n}{2}}$ configurações possíveis de alocação entre tratamento e controle.
- Intuição: estamos jogando fora as aleatorizações "indesejáveis".
- Cálculo da variância é mais complexo

### Aleatorização Condicional (Block Random Assigment)

- **Definição**: Experimento é condicionalmente aleatório se a aleatorização depende de variáveis pré-tratamento $X$.
- **Exemplo Binário**: Duas moedas, uma para $X=1$ e outra para $X=0$.
- **Aleatorização Marginal vs. Condicional**:
    - Marginal: Aleatorização uniforme para todos os indivíduos.
    - Condicional: Aleatorização depende de $X$, gerando permutabilidade condicional a $X$.
- **Permutabilidade Condicional**: $(Y^1, Y^0 | X=x) \indep T$.

- Não gera permutabilidade (não-condicional).
- Permutabilidade condicional a $X$ é crucial para inferência em contextos com variáveis pré-tratamento.

### Pensando aleatorização em bloco

- Ex.: digamos que em um amostra de 100 pessoas, queremos 25 homens e 25 mulheres no tratamento e controle
- Sorteio 25 homens para tramento e depois 25 mulheres.
- Cada bloco possui tamanho 25, neste exemplo.
- Blocos de tamanho $2$ são chamados de *pair-matched design*.
- Em geral, estudos com *matching* em muitas variáveis
- Útil para amostras pequenas

### ATE com Aleatorização Condicional (Bloco)

- Estratitificação
- Efeito heterogêneo por estrato?
- Podemos calcular o ATE por estrato, já que é aleatório no interior de cada estrato.
- Efeito geral na população.
- Podemos calcular ponderando os ATEs.
- Seja $J$ o número de estratos, indixados por $j$. Seja $N$ o número de unidades e $N_j$ o número de unidades no bloco $j$. Então:
- $ATE = \sum_{j=1}^J \frac{N_j}{N}ATE_j$

### Aleatorização em bloco
-- Pela Lei dos Grandes números, tende a gerar balanceamento entre blocos
-- Balanceamento quer dizer que blocos são similares
-- Em variáveis observadas e não-observadas
-- Probabilidade de tratamento pode variar por bloco. 
-- Chamada de propensity score.

### Precisão da aleatorização em bloco
- Em geral a precisão aumenta (erro padrão diminui) com aleatorização em bloco.
- Intuição é que removemos parte da variância (amostras possíveis), condicionando nos estratos
- Vamos checar uma simulação no R para ver um exemplo do ganho na precisão
- Lembrem-se que se $X$ e $Y$ são independentes, então $Var(aX + bY) = a^2Var(x) + b^2Var(Y)$.


```{r echo=TRUE, eval=TRUE}
# Set up Potential outcomes and units and blocks
n1 <- 10
n2 <- 16
N <- n1+n2
J <- 2
index_block <- c(rep(2, n2), rep(1, n1))
set.seed(12)
# potential outcome control
y0 <- c(rnorm(n1, 2, 1),rnorm(n2, 6, 1)) 
y1 <- y0 + 1.5 # potential outcome treatment
```


```{r echo=TRUE, eval=TRUE}
# block assignment
t_bloco1 <- sample(1:n1, n1/2)
c_bloco1 <- (1:n1)[!(1:n1 %in% t_bloco1)]

t_bloco2 <- sample((n1+1):(n1+n2), n2/2)
c_bloco2 <- ((n1+1):(n1+n2))[!((n1+1):(n1+n2) %in% t_bloco2)]

y1_obs_bloco1 <- y1[t_bloco1]
y1_obs_bloco2 <- y1[t_bloco2]
y0_obs_bloco1 <- y0[c_bloco1]
y0_obs_bloco2 <- y0[c_bloco2]
```



```{r echo=TRUE, eval=TRUE}
# random assignment
units_simple_treatment <- c(t_bloco1, t_bloco2)
units_simple_control <- c(c_bloco1, c_bloco2)
y1_obs <- y1[units_simple_treatment]
y0_obs <- y0[units_simple_control]

# erro padrão
erro_pad_simple <- t.test(y1_obs, y0_obs)$stderr 
simple_p_value <- t.test(y1_obs, y0_obs)$p.value

my_t <- mean(y1_obs - y0_obs)/erro_pad_simple
```



```{r echo=TRUE, eval=TRUE}
erro_pad1 <- t.test(y1_obs_bloco1, y0_obs_bloco1)$stderr
erro_pad2 <- t.test(y1_obs_bloco2, y0_obs_bloco2)$stderr

erro_padrao_geral <- sqrt(erro_pad1^2*(n1/N)^2 + erro_pad2^2*(n2/N)^2)
ate1 <- mean(y1_obs_bloco1 - y0_obs_bloco1)*(n1/N)
ate2 <- mean(y1_obs_bloco2 - y0_obs_bloco2)*(n2/N)
ate <- ate1 + ate2
my_t <- ate/erro_padrao_geral
p_value <- 2*(1 - pt(abs(my_t), df = 23.76567))
print(erro_pad1)
print(erro_pad1)
print(erro_padrao_geral)
print(p_value)
```

### Comparação de SEs

```{r tabela-se, echo=TRUE, eval=TRUE}
library(knitr)

comparison_table <- data.frame(
  Method = c("Simple Randomization", "Block 1", "Block 2", "General Block Randomization"),
  Standard_Error = c(erro_pad_simple, erro_pad1, erro_pad2, erro_padrao_geral)
)

knitr::kable(comparison_table, caption = "Comparação de Erros padrão", align = 'c', format = "latex")
```

### Cluster randomization

- Quando aleatorizo o cluster, em vez das unidades.
- Ex.: Se não for possível aleatorizar um tratamento entre estudantes, aleatorizo escolas
- No interior de cada escola, todo mundo é tratado ou não-tratado. Não há variação *within* escolas, apenas entre (between) escolas.
- Grande perda de variabilidade nos dados, reduzindo precisão (aumento no erro padrão)
- Às vezes é a única aleatorização possível.


```{r echo=FALSE, eval=TRUE}
library(knitr)

comparison_table1 <- data.frame(
  Method = c("Simple Randomization", "Block Randomization"),
  p_value = c(simple_p_value, p_value)
)

knitr::kable(comparison_table1, caption = "Comparação de valoes p", align = 'c', format = "latex")

```


### Tabelas em artigos

```{r resultado-tabela, echo=FALSE, fig.cap="Tabela de resultados.", out.width = '50%'}
## knitr::include_graphics("experiments_report.png")
```

## Estimador ATE


- estimativa: $\frac{\sum_{i=1}^{n}Y_iT_i}{n_1} - \frac{\sum_{i=1}^{n}Y_i(1-T_i)}{n_0} = .0608 - .0353 = 0.0255$
- Erro padrão: $\sqrt{\frac{\hat{\sigma_1^2}}{n_1} + \frac{\hat{\sigma_0^2}}{n_0}} = \sqrt{\frac{.0608\cdot(1-.0608)}{1217} + \frac{.0353\cdot (1-.0353)}{1217}} = 0.00865$
- Pequena diferença com os coeficientes da tabela
- Typo? Alguma informação não reproduz exatamente? Fizemos algo errado?



```{r echo=TRUE, eval=TRUE}
treatment <- c(rep(1, 74), rep(0, 1217 - 74))
control <- c(rep(1, 43), rep(0, 1217 - 43))
var_treat <- var(treatment) 
var_control <- var(control)
erro_padrao <- sqrt(var_treat/1217 + var_control/1217)
round(erro_padrao, 5)

t.test(treatment, control)      
```



## Key Takeways

- Experimento (sob SUTVA) elimina o viés de seleção
- Depende de restrição de exclusão e simetria
- Vários tipos de experimentos: block aumenta precisão
- Com N grande, diferença diminui
- Sempre supomos condições ideais (sem attrition, compliance perfeito etc.)

## Declare Design

Uma ferramenta muito útil para experimentos (mas também para estudos observacionais) é o pacote do R Declare Design.

Blair, Coppock e Humphreys criaram um framework para definir e avaliar um desenho de pesquisa. Com oresultado, escreveram um livro "Research Design in the Social Sciences", e um pacote no R para implementar os conceitos desenvolvidos no livro, chamado "DeclareDesign. Para instalar (junto com os datasets usados no livro), basta rodar `r ## install.packages(c("DeclareDesign", "rdss"))`.

O frameowrk é baseado no acrônimo MIDA, que contempla os quatro elementos básicos de um desenho de pesquisa:  models, inquiries, data strategies, and answer strategies.

Ou seja, você deve especificar um modelo, qual pergunta de pesquisa (aka estimando), quais dados vai utilizar e como vai estimar o estimando.

Um modelo descreve o que causa o que e como. Tipicamente especifica a as unidades, o tamanho da amostra e a equação de resultados potenciais.
Suponha que quero rodar um experimento aleatório com um tratamento e controle (two-arm randomized experiment). Assim, podemos declarar um modelo com:


```{r declare-model, eval=TRUE, message=FALSE}
library(DeclareDesign)
model <- declare_model(
    N = 500,
    X = rep(c(0, 1), each = N / 2), # tratamento e controle
    U = rnorm(N, sd = 0.25), # heterogeneidade exógena
    potential_outcomes(Y ~ 0.2 * Z + X + U)
)
```

Vamos entender o que fizemos. 

1. Declaramos que nossa população terá $500$ observações: `r N = 500`. Nesse exemplo, a amostra será igual a populacão, mas poderíamos amostrar da população se quiséssemos.

2. Declaramos que $X$, uma covariável, pode assumir dois valores (0,1), e atribuimos a priemria metade pra $0$ e a outra metade para $1$: `r X = rep(c(0, 1), each = N / 2)`.

3. Declaramos que existe uma variável $U$ que tem distribuição normal, com $N$ observações e média $0$ e desvio-padrão $.25$:`r U = rnorm(N, sd = 0.25)`.
 
4. Declaramos que os resultados potenciais diferem em $20\%$ entre tratamento e controle ($Z$) para cada unidade. Uma forma alternativa e talvez mais clara de declarar a relação entre tratamento/controle e resultados potenciais seria escrever `r # potential_outcomes(Y_Z_0 = X + U, Y_Z_1 = Y_Z_0 + 0.2)`.

4.1. Além disso, $X$ tem efeito de $1$ para todas as unidades.

Vamos passar agora ao nosso estimando ou *inquiry*.

```{r declare-inquiry, eval=TRUE, message=FALSE}
inquiry <- declare_inquiry(ATE = mean(Y_Z_1 - Y_Z_0))

```

Se estamos interessados no ATE, é só declarar que é a média da diferença entre os resultados potenciais. Podemos também usar a função `r # declare_estimand()`
Outras possibilidaes incluem o ATT `r # declare_inquiry(ATT = mean(Y_Z_1 - Y_Z_0), subset = (Z == 1))` e CATE: `r # declare_inquiry(CATE = mean(Y_Z_1 - Y_Z_0), subset = X == 1)`, por exemplo. Formulação equivalente para o ATT seria `r # declare_inquiry(ATT = mean(Y_Z_1|Z = 1) - mean(Y_Z_0|Z=1))`.

Estratégia de dados

```{r declare-data, eval=TRUE, message=FALSE}

data <- declare_assignment(Z = complete_ra(N = N, m = 250)) + # assigment mechanism
  declare_measurement(Y = reveal_outcomes(Y ~ Z)) # reveal_outcomes é a switching equation

```


```{r declare-estimator, eval=TRUE, message=FALSE}

estimator <- declare_estimator(Y ~ Z, inquiry = "ATE")

```


```{r two-arm-trial, eval=TRUE, message=FALSE}

two_arm_trial <- model +
  inquiry +
  data +
  estimator

# Draw a simulated dataset 
head(draw_data(two_arm_trial), 10)

```


Após declarar um desenho de pesquisa, podemos diagnosticar se nosso desenho de pesquisa pode ser respondido adequadamente (isto é, se é identificável, se possui poder para estimar com precisão o efeito de interesse etc.). Podemos inclusive modificar o desenho para responder a outras perguntas (é generalizável para outras populações, diferentes estimadores pdesempenham melhor etc.)

Eis um exemplo de diagnóstico:

```{r dianostico, eval=TRUE, message=FALSE}

diagnose_design(two_arm_trial, sims = 100)

```

Podemos ajustar o desenh ode pesquisa

```{r redesenho, eval=TRUE, message=FALSE}

designs <- redesign(two_arm_trial, N = c(100, 200, 300, 400, 500))
diagnose_design(designs)
```

## Exercício

O exercício abaixo é uma tradução de questões que estavam presentes no exame de qualificação (prelims) da área de métodos do programa de doutorado em ciência política de Yale.

### Experimento com envio de cartões-postais e participação eleitoral

Você conduz um experimento aleatório para testar o efeito de um cartão-postal sobre a participação eleitoral, sorteando independentemente uma moeda para cada sujeito com probabilidade $0 < p < 1$ de receber o tratamento. Assuma o pressuposto de SUTVA (Stable Unit Treatment Value Assumption). Você estima o seguinte modelo por Mínimos Quadrados Ordinários (OLS):

$$
Y_i = \beta_0 + \beta_1 T_i + \beta_2 S_i + \beta_3 T_i S_i + u_i
$$

em que:
- $Y_i$ indica se o indivíduo votou (variável dependente);
- $T_i$ é o indicador binário de tratamento (receber ou não o cartão-postal);
- $S_i$ é um indicador binário que vale 1 se o indivíduo vive em um estado eleitoralmente competitivo (battleground state) e 0 caso contrário;
- $T_i S_i$ é a interação entre o tratamento e o contexto competitivo.

#### (a) Interprete os quatro coeficientes $\beta$

- $\beta_0$: média de $Y_i$ (taxa de votação) para o grupo controle ($T_i = 0$) em estados não competitivos ($S_i = 0$).
- $\beta_1$: efeito médio do tratamento (cartão-postal) em estados **não competitivos**. Como o tratamento foi atribuído aleatoriamente, $\beta_1$ tem interpretação causal.
- $\beta_2$: diferença na taxa média de votação entre estados competitivos e não competitivos **no grupo controle**. Não tem interpretação causal.
- $\beta_3$: diferença no efeito do tratamento entre estados competitivos e não competitivos. Se $\beta_3 \neq 0$, o efeito do cartão-postal depende do tipo de estado. Como o tratamento é aleatório, $\beta_3$ também tem interpretação causal.

#### (b) Como testar a hipótese de que o efeito do tratamento é igual entre os dois tipos de estado?

Testa-se a hipótese nula $H_0: \beta_3 = 0$. Isso pode ser feito diretamente a partir do resultado da regressão usando um teste t para o coeficiente da interação $T_i S_i$.



### Experimento com anúncios de TV e participação eleitoral

Você quer testar se anúncios de TV aumentam a participação eleitoral. O experimento pode ser conduzido em até 16 mercados de mídia, dos quais até 8 podem ser sorteados para o grupo de tratamento. Os anúncios só podem ser exibidos para o mercado de mídia como um todo.

Você tem informações individuais para todos os eleitores elegíveis nesses mercados: mercado de mídia, idade, sexo, raça/etnia e participação nas duas eleições anteriores. Após a eleição, você receberá os dados atualizados sobre participação no pleito atual.

#### (a) Como alocar aleatoriamente os mercados ao tratamento?

Sorteie aleatoriamente 8 dos 16 mercados de mídia para o grupo de tratamento. Como o tratamento é atribuído no nível do mercado, essa é a unidade de aleatorização. Recomenda-se balancear o sorteio usando pareamento ou estratificação com base em características agregadas dos mercados (por exemplo, participação passada, composição demográfica), se houver variação relevante entre eles.

#### (b) Como analisar esse experimento?

A análise deve ser feita no nível do mercado de mídia, que é a unidade de tratamento. Uma abordagem válida é calcular a média da taxa de votação em cada mercado e rodar uma regressão simples:

$$
\bar{Y}_j = \alpha + \tau D_j + \varepsilon_j
$$

em que:
- $\bar{Y}_j$ é a média da taxa de votação no mercado $j$;
- $D_j$ é um indicador de tratamento para o mercado;
- $\tau$ estima o efeito médio do tratamento.

É possível incluir covariáveis no nível do mercado para aumentar a precisão, mas não é necessário para validade causal.

---

### Exclusão de participantes em experimentos de survey

Pesquisadores às vezes excluem participantes de um experimento de survey por:
1. Não passarem em uma checagem de atenção pré-tratamento;
2. Não passarem em uma checagem de atenção pós-tratamento;
3. Completarem o survey muito rapidamente (por exemplo, 3 desvios-padrão abaixo da média de tempo).

#### (a) Se o interesse é no efeito médio do tratamento **entre os sujeitos que não foram excluídos**, qual dessas estratégias é não-viesada?

Todas essas estratégias podem fornecer estimativas **não viesadas** para o efeito médio do tratamento entre os sujeitos que **permanecem** na amostra, desde que os critérios de exclusão sejam **pré-tratamento** ou **não afetem diferencialmente** os grupos de tratamento e controle. A exclusão baseada em variáveis observadas **antes do tratamento** (como checagem pré-tratamento ou tempo de resposta) é menos problemática.

Já a exclusão com base em comportamentos **após** o tratamento (como falha em atenção pós-tratamento) pode introduzir viés, pois pode estar correlacionada com a resposta ao tratamento.

#### (b) Se o interesse é no efeito médio do tratamento **entre todos os participantes que iniciaram o experimento**, qual dessas estratégias é não-viesada?

Nenhuma das exclusões garante uma estimativa não viesada nesse caso. Excluir participantes com base em qualquer critério — mesmo que relacionado à atenção ou tempo de resposta — altera a composição da amostra em relação ao universo original. Para estimar o efeito médio para todos os participantes que começaram o experimento, é necessário **manter todos os sujeitos**, independentemente do desempenho em checagens ou tempo de resposta.



<!--chapter:end:04-Experimentos.Rmd-->

# Propensity Score e Matching

## Introdução

Na aula de hoje, iremos aprender sobre a principal estratégia de "seleção em observáveis", que é matching. Mas antes, vamos falar de subclassificação ,que é uma técnica mais simples e é útil para introduzir a ideia de matching.

## Propensity Score

O propensity score nada mais é que a probabilidade de uma unidade ser tratada, dada as covariáveis, ou seja, $Pr(D_i = 1| X_i)$.

A ideia chave para propensity-score vem de um paper de Rosenbaum-Rubin (1983) em que eles mostram que, se a condição 1 de ignorabilidade forte (isto é, $Y_i(1), Y_i(0) \perp D_i|X_i$) for satisfeita, então também é verdade que a condição $Y_i(1), Y_i(0) \perp D_i|\pi(X_i)$ também é satisfeita. E por que isso é importante? Nós nunca sabemos o verdadeiro modelo que relaciona as convariáveis $X_i$ com $D_i$ e $Y_i$, de modo que podemos ter algum problema de modelo mal especificado (por exemplo, supomos um modelo linear, quando na verdade é não-linear). Então, em vez de estimar dezenas de modelos, posso condicionar ("controlar") apenas pelo propensity score $\pi(X_i)$. A intuição é que o propensity score cria balanceamento entre tratados e não-tratados. 

Para ilustrar o poder desse reusltado, vamos considerar um exemplo simulado, em que ignorability forte é satisfeita, mas um modelo mal-especificado gera amostras não-balanceadas e, portanto, estimativas viesadas.

```{r modelo-mal-especificado-DAG, message=FALSE}
library(knitr)
library(tidyverse)
library(ggdag)
library(arm)
# true DGP
dag <- dagify(
  y ~ D + w1,
  D ~ w1
)

ggdag(dag)
```

O DAG acima ilustra bem qual a relação causal entre variáveis. Para estimar o ATE de $D$ sobre $Y$, precisamos fechar o backdoor de $w_1$. A forma usual como fazemos isso é com regressão. O problema que estamos abordando aqui é quando a amostra é não-balanceada entre tratados e não-tratados, isto é. Vamos visualizar dois tipos de relações (uma linear e outra não-linear) entre a variável de controle $w_1$ e a resposta $Y$ para ilustrar o problema do desbalanceamento:

```{r modelo-mal-especificado-plot1, message=FALSE}
library(ggplot2)
set.seed(202)
n  <- 1e4
w1 <- rnorm(n)                       # único confundidor
tau <- 3                             # efeito causal verdadeiro

# GERAMOS UM PROPENSITY SCORE NÃO‐LINEAR
p  <- plogis(-0.5 + 2 * w1) 
D  <- rbinom(n, 1, p)

# GERAÇÃO DOS RESULTADOS POTENCIAIS linear (apenas função de w1, forte ignorabilidade):
y0 <-  5 * w1 + rnorm(n)
y1 <- y0 - tau                       # efeito constante

y  <- ifelse(D == 1, y1, y0)



df <- data.frame(y=y, D=D, w1=w1)

df %>%
  mutate(
    D = factor(D, levels = c(0,1),
               labels = c("Controle (D = 0)", "Tratado (D = 1)"))
  ) %>%
  ggplot(aes(x = w1, y = y, colour = D)) +
  geom_point(alpha = 0.6) +
  scale_colour_manual(
    name   = "Tratamento (binário)",
    values = c("Controle (D = 0)" = "steelblue", 
               "Tratado (D = 1)"  = "firebrick")
  ) + theme_bw()
```

No primeiro gráfico, o efeito causal (ATE) do tratamento é $-3$ e podemos ver nos dados que de fato em média a resposta é menor entre tratados que no controle. Além disso, vemos também que o efeito é basicamente linear. Mas o pontpo importante aqui é que existem duas regiões dos dados em que praticamente só temos unidades no controle ($w_1 < -2$) e ou no tratamento ($w_1 > -2$). Isso significa que para que a regressão possa estimar o efeito causal deve extrapolar a estimativa da região em que ambos tratamento e controle estão presentes nos dados para uma região em que não estão presentes. Como o efeito é constante para todas as regiões de $w_1$, isso não causa problema e a regressão consegue recuperar o ATE sem viés. O gráfico abaixo ilustra o que a regressão está fazendo:

```{r modelo-mal-especificado-plot1-reg, message=FALSE}

df %>%
  mutate(
    D = factor(D, levels = c(0,1),
               labels = c("Controle (D = 0)", "Tratado (D = 1)"))
  ) %>%
  ggplot(aes(x = w1, y = y, colour = D)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm") +
  scale_colour_manual(
    name   = "Tratamento (binário)",
    values = c("Controle (D = 0)" = "steelblue", 
               "Tratado (D = 1)"  = "firebrick")
  ) + theme_bw()
```

O gráfico mostra duas retas de regressão ajustadas, uma para o controle (em azul) e outra para o tratamento (em vermelho). Efetivamente, temos de estender as duas retas para as regiões em que não há dados, por meio de extrapolação, que no caso significa continuar a linha reta. Assim, temos uma estimativa dos resultados potenciais nessas regiões e podemos computar o efeito causal médio. Como a extrapolação é razoável, não há problema.

Vejamos agora uma situação em que o efeito de $w_1$ é não linear sobre $Y$.
 

```{r modelo-mal-especificado-plot2, message=FALSE}

set.seed(202)
n  <- 1e4
w1 <- rnorm(n)                       # único confundidor
tau <- 3                             # efeito causal verdadeiro

# GERAMOS UM PROPENSITY SCORE NÃO‐LINEAR
p  <- plogis(-0.5 + 2 * w1) 
D  <- rbinom(n, 1, p)

# GERAÇÃO DOS RESULTADOS POTENCIAIS não-linear (apenas função de w1, forte ignorabilidade):
y0 <-  5 * w1^2 + rnorm(n)
y1 <- y0 - tau                       # efeito constante

y  <- ifelse(D == 1, y1, y0)



df <- data.frame(y=y, D=D, w1=w1)

df %>%
  mutate(
    D = factor(D, levels = c(0,1),
               labels = c("Controle (D = 0)", "Tratado (D = 1)"))
  ) %>%
  ggplot(aes(x = w1, y = y, colour = D)) +
  geom_point(alpha = 0.6) +
  scale_colour_manual(
    name   = "Tratamento (binário)",
    values = c("Controle (D = 0)" = "steelblue", 
               "Tratado (D = 1)"  = "firebrick")
  ) + theme_bw()
```

Aqui, vemos que o efeito é não-linear de $w_1$ sobre $Y$ e também o desbalanceamento na amostra. Vamos ver o mesmo gráfico com as duas retas ajustadas para entender como a extrapolação pode ficar bem ruim nesse caso. 


```{r modelo-mal-especificado-plot2-reg, message=FALSE}

df %>%
  mutate(
    D = factor(D, levels = c(0,1),
               labels = c("Controle (D = 0)", "Tratado (D = 1)"))
  ) %>%
  ggplot(aes(x = w1, y = y, colour = D)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm") +
  scale_colour_manual(
    name   = "Tratamento (binário)",
    values = c("Controle (D = 0)" = "steelblue", 
               "Tratado (D = 1)"  = "firebrick")
  ) + theme_bw()
```

Um problema óbvio do modelo é que o efeito de w1 é quadrático, então podemos tentar corrigir isso incluindo um termo quadrático.

```{r modelo-mal-especificado-reg-sq, message=FALSE}
reg_sq <- lm(y ~ D + w1 + w1^2, data = df)
summary(reg_sq)
```
O efeito causal é negativo, o que é bom, pois está na direção certa, mas ainda está distante do efeito verdadeiro. Isso ilustra também como a estimativa é dependente do modelo, o que é bem ruim, pois não sabemos qual o modelo certo.

Em resumo, quando há desbalancamento, causamos dependência do modelo, o que é problemático.

Agora, vamos comparar com o propensity score:

```{r modelo-mal-especificado, message=FALSE}
library(knitr)
library(tidyverse)
library(ggdag)
# true DGP

reg_aux<- glm(D  ~ w1, family = binomial, data=df)
p_score <- reg_aux$fitted.values
reg1 <- lm(y ~ D + p_score)
summary(reg1)

w <- ifelse(D == 1, 1/p_score, 1/(1-p_score))   # pesos IPTW

reg2 <- lm(y ~ D , weights = w)
summary(reg2)

```


Conseguimos recuperar o ATE sem problemas. E não precisei especificar corretamente a forma funcional da variáveil de controle $w_1$ no modelo principal, pois usei o propensity score. Note que precisei modelar corretamente a regreessão que calcula o propensity score. 

É útil ver como o pscore está distribuído entre os grupos de tratamento e controle:


```{r distribuicao-pscore, message=FALSE}
library(knitr)
library(tidyverse)
library(ggdag)
# true DGP

df <- df %>%
  mutate(pscore = p_score)

df %>%
  ggplot(aes(pscore, group=D)) + geom_boxplot()

df %>%
  mutate(D = as.factor(D)) %>%
  ggplot()+
  geom_density(aes(x=pscore, group=D, colour = D))

```

Há desbalanceamento e falta de overlap ou suporte comum, o que leva à extrapolação.

## Matching

A Ideia do matching pode ser ilustrada se notarmos o seguinte. A projeção da reta vermelha para pontos abaixo de $-2$ é de um $y$ médio muito baixo, enquanto que o $y$ médio é muito alto para o controle. O oposto é verificado para a região em que $w_1 > 2$. Portanto, se eu restringir (excluir os casos) a análise para uma região onde a necessidade de extrapolação é menor, o resultado tende a ser aproximar do ATE

```{r modelo-mal-especificado-reg-sub, message=FALSE}
library(knitr)
library(tidyr)
library(broom)
library(kableExtra)

reg_sub <- lm(y ~ D + w1, data = df)

reg_sub %>%
  tidy() %>%
  kable(digits = c(0, 2, 3, 2, 3))

reg_sub <- lm(y ~ D + w1, data = subset(df, w1 > -2 & w1 < 2))

reg_sub %>%
  tidy() %>%
  kable(digits = c(0, 2, 3, 2, 3))


reg_sub <- lm(y ~ D + w1, data = subset(df, w1 > -1.5 & w1 < 1.5))

reg_sub %>%
  tidy() %>%
  kable(digits = c(0, 2, 3, 2, 3))


reg_sub <- lm(y ~ D + w1, data = subset(df, w1 > -1 & w1 < 1))

reg_sub %>%
  tidy() %>%
  kable(digits = c(0, 2, 3, 2, 3))


reg_sub <- lm(y ~ D + w1, data = subset(df, w1 > -1 & w1 < 1))

reg_sub %>%
  tidy() %>%
  kable(digits = c(0, 2, 3, 2, 3))

```

A ideia do matching é um pouco diferente do que fizemos acima, pois estamos excluindo as observações que estão no tratamento e que não possuem controle correspondente, e do controle que não possuem tratamento correspondente. Não há erro em excluir os dois tipos de observações, mas sempre temos de nos perguntar qual é o estimando de interesse. Se faço esse procedimento, o meu estimando não é nenhum dos usuais ATT ou ATE.

No matchingf, nós nos concentramos em estimar o ATT, de forma que procuramos achar observações no controle que são próximas das tratadas, ou seja, excluímos os controles que não são um match para as observações tratadas.

## Suposições de identificação

Supondo para simplificar um tratamento binário $T$, e uma covariável categórica $X$, temos:

1. $(Y^1, Y^0) \perp T|X \text{ (Independência Condicional)}$

2. $0 < P(T=1|A) < 1 \text{ (Suporte comum)}$

Temos então a seguinte derivação (usando o fato de os resultados potenciais são independentes do *treatment assignment*, condicional à covariável) e a *switching equation* no último passo:

\begin{align}
   \mathbb{E}[Y^1-Y^0|X] & = \mathbb{E}[Y^1 - Y^0 | X, T=1] \\
            & = \mathbb{E}[Y^1| X, T=1] - \mathbb{E}[Y^0| X,T=0] \\
            & = \mathbb{E}[Y| X, D=1] - \mathbb{E}[Y| X, D=0]
\end{align}

E o estimador que usamos pode ser representado (supondo suporte comum) como:

$\widehat{\delta_{ATE}} = \sum_{x\in X}{(\mathbb{E}[Y| X=x, D=1] - \mathbb{E}[Y| X=x, D=0])P(X=x)}$

E o que estamos fazendo é computar a média do efeito do tratamento condicional ponderado pela distribuição de $X$.

Para identificar o ATE, nós precisamos supor independência condicional a ambos os resultados potenciais. Se porém isso for crível apenas para $Y^0$, podemos estimar o ATT. Basta lembrarmos que $\mathbb{E}[Y_i|T_i=1] - \mathbb{E}[Y_i|T_i=0] =  \mathbb{E}[Y_i^1 - Y_i^0|T_i=1] + \mathbb{E}[Y_i^0|T_i=1] - \mathbb{E}[Y_i^0|T_i=0]$

## Matching

A técnica de matching trata os resultados potenciais como *missing data*. Assim, pudermos supor CIA com credibilidade, pelo menos com relação a $Y^0$, então podemos imputar esses resultados potenciais e estimar o ATT. A ideia é achar uma unidade a mais similar possível a unidade tratada para servir como contrafactual. Assim, poderíamos computar "diretamente" o ATT, já que teríamos os $Y^1$ e $Y^0$ para cada unidade, este último imputado.

Há dois grandes grupos de métodos de matching: exato e aproximado. 

## Matching exato

Nesse método, nós achamos uma unidade (ou mais) que tenham um valor exatamente igual nas covariáveis (ou no propensity score), e imputamos o controle.

## Matching aproximado

Para aproximar o matching, utilizamos alguma noção de distância entre variáveis. Para mais de uma variável, podemos utilizar algumas métricas de distância. A primeira é a distância euclidiana (supondo $K$ variáveis).

$$
\lVert X_i - X_j \rVert = \sqrt{(X_i - X_j)'(X_i - X_j)}
$$
$$
\lVert X_i - X_j \rVert = \sqrt{\sum_{n=1}^k(X_{ni} - X_{nj})}
$$

A distância euclidiana utiliza a escala das próprias variáveis, então é comum usar a distância euclidiana normalizada:

$$
\lVert X_i - X_j \rVert = \sqrt{\sum_{n=1}^k(\frac{X_{ni} - X_{nj})}{\hat{\sigma}_n^2}}
$$

Outra métrica é a distância de Mahalanobis, que basicamente divide pela covariância (amostral) entre as variáveis em vez da variância. Mas na prática a gente usa a euclidiana.

## Estimando

Uma vez que fizemos o matching entre unidades, qual nosso estimador? Lemrbando que o estimando é o ATT.
$$
\widehat{\delta}_{ATT} = \dfrac{1}{N_T} \sum_{D_i=1} (Y_i - Y_{j(i)})
$$

```{r balanceamento, message=FALSE}
library(MatchIt)
result_0 <- matchit(D ~ w1, data = df, method = NULL, distance = 'glm')
summary(result_0)
```


## Declare Design e Matching

Pode ser útil usar o declare design para investigar o uso de matching. Vamos fazer isso para o dataset lalonde.

Esse é um banco de dados famoso na economia, pois o pesquisador Lalonde (1986) foi investigar se aplicação de métodos (então) tradicionais de modelagem econométrica eram capaz de recuperar o efeito causal de um estudo experimental chamada National Supported Work Demonstration (NSW), um programa de emprego temporário para dar experiência de trabalho. Ele coletou dados de um survey "representativo" de trabalhadores americanos (PSID) e elencou esses trabalhadores como grupo controle e empregou métodos econométricos para tentat estimar o efeito causal. Os resultados foram desastrosos, no sentido de altamente variáveis dependendo do modelo e subconjunto de dados e longe da estimativa experimental (incluindo com sinal errado).

Vamos replicar esse trabalho, usando matching e pscore. A variável resposta do banco de dados é ``re78`` (real earnings in 1978). O tratamento é a variável ``treat``. As demais variáveis são covariáveis.

```{r setup-lalonde, echo=TRUE, eval=TRUE, message=FALSE}
library(tidyverse)
library(data.table)
library(here, quietly=TRUE)
library(fixest)
here()
set.seed(1234)
```

```{r lalonde, echo=TRUE, eval=TRUE, message=FALSE}
lalonde <- fread(here("Dados", "lalonde_nsw.csv"))

dt <- lalonde[, .(re78, treat)] %>%
    rename(Y = re78, D = treat)

dt %>%
    group_by(D) %>%
    sample_n(3) %>%
    kableExtra::kable(digits = 0, col.names = c("Income", "Treatment"))
```



```{r}
dt %>%
    group_by(D) %>%
    summarize(mean(Y)) %>%
    kableExtra::kable(digits = 0, col.names = c("Treatment", "Income"))
y1 = dt[dt$D == 1, Y]
y0 <- dt[dt$D == 0, Y]
tau <- mean(y1) - mean(y0)
```

A diferença simples na média é `r round(tau, digits = 0)`.

### Matching e Propensity scores

Usando ``age, education, hispanic, black, married, nodegree, RE74`` e ``RE75``, vamos moelar o propensity score usando o grupo dos tratados em ``lalonde_nsw.csv`` e a amostra de controle de ``lalonde_psid.csv``. Report the average p-score for the treated and control samples, and plot the propensity score densities for the treatment and control groups.

```{r observational-data, message = FALSE}
nsw_data <- lalonde
psid_data <- fread(here("Dados", "lalonde_psid.csv"))

nsw_treat <- nsw_data[nsw_data$treat == 1, ]
psid_control <- psid_data[psid_data$treat == 0, ]

dw_data <- rbind(nsw_treat, psid_control)

library(MatchIt)
m.out1 <- matchit(treat ~ age + education + hispanic + black + married + nodegree + re74 + re75,
                  data = dw_data,
                  method = "nearest",
                  distance = "glm")

summary(m.out1)

plot(summary(m.out1))

m.data <- match_data(m.out1)

head(m.data)

library("marginaleffects")

fit <- lm(re78 ~ treat * (age + education + black + married +
                            nodegree + re74 + re75),
          data = m.data,
          weights = weights)

avg_comparisons(fit,
                variables = "treat",
                vcov = ~subclass,
                newdata = subset(treat == 1))

```

```{r exact-matching, message = FALSE}
library(MatchIt)
library(DeclareDesign)
exact_matching <-
  function(data) {
    matched <- matchit(D ~ X, method = "exact", data = data)
    match.data(matched)
  }

declaration_16.2 <-
  declare_model(
    N = 100,
    U = rnorm(N),
    X = rbinom(N, 1, prob = 0.5),
    D = rbinom(N, 1, prob = 0.25 + 0.5 * X),
    Y_D_0 = 0.2 * X + U,
    Y_D_1 = Y_D_0 + 0.5
  ) +
  declare_inquiry(ATT = mean(Y_D_1[D == 1] - Y_D_0[D == 1])) +
  declare_step(handler = exact_matching) +
  declare_measurement(Y = reveal_outcomes(Y ~ D)) +
  declare_estimator(Y ~ D,
                    weights = weights,
                    .method = difference_in_means,
                    inquiry = "ATT",
                    label = "Matched difference-in-means") +
  declare_estimator(Y ~ D,
                    .method = difference_in_means,
                    inquiry = "ATT",
                    label = "Raw difference-in-means")

```



```{r balance}
library(MatchIt)
m.out0 <- matchit(treat ~ age + education + hispanic + black + married + nodegree + re74 + re75,
                  data = dw_data,
                  method = NULL,
                  distance = "glm")

# Checking balance prior to matching
summary(m.out0)

```

```{r propensity-scores-matching}
library(MatchIt)
m.out1 <- matchit(treat ~ age + education + hispanic + black + married + nodegree + re74 + re75,
                  data = dw_data,
                  method = "nearest",
                  distance = "glm")

# Full matching on a probit PS
m.out2 <- matchit(treat ~ age + education + black + married + 
                    nodegree + re74 + re75,
                  data = lalonde,
                  method = "full",
                  distance = "glm",
                  link = "probit")

m.data <- match_data(m.out2)

library("marginaleffects")

fit <- lm(re78 ~ treat * (age + education + black + married +
                            nodegree + re74 + re75),
          data = m.data,
          weights = weights)

avg_comparisons(fit,
                variables = "treat",
                vcov = ~subclass,
                newdata = subset(treat == 1))
```



```{r DD-full-matching, message = FALSE}


full_matching <-
  function(data) {
    matched <- matchit(treat ~ age + education + hispanic + black + married + nodegree + re74 + re75, method = "full", data = data)
    match.data(matched)
  }

declaration_16.2 <-
  declare_model(
    N = 1000,
    U = rnorm(N),
    X = rbinom(N, 1, prob = 0.5),
    D = rbinom(N, 1, prob = 0.25 + 0.5 * X),
    Y_D_0 = 0.2 * X + U,
    Y_D_1 = Y_D_0 + 0.5
  ) +
  declare_inquiry(ATT = mean(Y_D_1[D == 1] - Y_D_0[D == 1])) +
  declare_step(handler = exact_matching) +
  declare_measurement(Y = reveal_outcomes(Y ~ D)) +
  declare_estimator(Y ~ D,
                    weights = weights,
                    .method = difference_in_means,
                    inquiry = "ATT",
                    label = "Matched difference-in-means") +
  declare_estimator(Y ~ D,
                    .method = difference_in_means,
                    inquiry = "ATT",
                    label = "Raw difference-in-means")

```

## Recomendações Práticas sobre Matching

Rotina ou algoritmo:

1. Defina o que é proximidade: alguma distância de medida para determinar se um caso é um bom match e quais variáveis utilizar. Em geral, distância euclidiana.

2. Implemente o método do match.

3. Avalie a qualidade do método, por meio do balanceamento antes e depois do match. Se necessário, altere o passo 1 ou 2 e itere.

4. Faça a inferência sobre o efeito causal do tratamento sobre a resposta, dado o matching feito em 3. 
### Avaliação do matching feito

1. É melhor usar matching exato ou aproximado do que propensity score matching, pois o poder do teste é melhor (cf. King & Nielsen, 2019).

2. Não devemos fazer teste de hipótese para checar que o balanceamento após matching é melhor do que antes (amostra menor reduz o poder do teste de detectar desbalanceamento. Além disso, não há superpopulação alvo da inferência, pois balanceamento é uma propriedade de uma amostra em particular). Cf. Austin 2009.

3. Além de comparar médias, é recomendado comparar variâncias ou desvios-padrão (Austin 2009). Por exemplo, razão de variâncias.

4. Jamais use a variável resposta para fazer o matching.

5. Matching com reposição gera dificuldades para calcular o erro padrão, já que as observações não são independentes.

## Referências

Austin, P. C. (2009). Balance diagnostics for comparing the distribution of baseline covariates between treatment groups in propensity‐score matched samples. Stat Med.

King, G., & Nielsen, R. (2019). Why propensity scores should not be used for matching. Political analysis, 27(4), 435-454.

Stuart, E. A. (2010). Matching methods for causal inference: A review and a look forward. Statistical science: a review journal of the Institute of Mathematical Statistics, 25(1), 1.

<!--chapter:end:05-Matching.Rmd-->

# Variáveis Instrumentais

## Introdução

Considere o seguinte DAG canônico de Variáveis Instrumentais:


```{r dag-diagram1, echo=FALSE, message=FALSE}
library(ggdag)
dag_iv <- dagify(
  T ~ Z + U,             # T ← Z, T ← U
  Y ~ T + U,             # Y ← T, Y ← U
  latent   = "U",        # U não observado
  exposure = "T",
  outcome  = "Y",
  coords = list(
    x = c(Z = 0, T = 1, U = 1, Y = 2),
    y = c(Z = 2, T = 2, U = 4, Y = 2)
  )
)

# 2. Plotar o DAG:
ggdag(dag_iv, text = FALSE) +
  geom_dag_text(size = 5) +      # adiciona rótulos nos nós
  geom_dag_edges() +             # desenha as arestas
  theme_dag()                    # tema minimalista para DAG

```



Nós vemos que o efeito causal do tratamento $T$ é confundido pela variável não observada $U$, já que temos um *backdoor* aberto. Porém, a variável $Z$ não tem nenhum caminho aberto para $Y$ exceto via $T$, isto é, $T$ é um mediador do efeito causal de $Z$.

Do ponto de vista não paramétrico (DAGs), dizemos que a variável $Z$ é uma **candidata** a variável instrumental (IV) se:

1. $Z$ está conectado a X no grafo original. Condição de **relevância**.

2. No grafo em que a seta de $T$ para $y$ é removida, $Z$ é d-separado de $Y$. **Exclusion Restriction**.

3. A variável instrumental $Z$ não compartilha causa comum com $y$, incluindo, portanto, não ser descendente de $T$. **Causa comum**.

Remark: Pode acontecer de ser necessário controlar para uma conjunto de covariáveis $X$ para que a segunda condição seja satisfeita. Chamamos isso de IV condicional.

Remark 2: Dizemos que uma variável $Z$ é **candidata** a ser VI porque as três condições acima, ainda que necessárias, não são suficientes para uma variável ser considerada VI. Veremos mais à frente porque isso acontece e o que mais é necessário para uma variável ser considerada VI.
Considere o DAG abaixo.

Remark 3: A literatura econométrica não costuma deixar muito clara a condição 3. Às vezes falam que $Z$ deve causar $T$ (o que implica que não há causa comum em um DAG). Porém, isso não é correto, como o DAG abaixo mostra, em que, controlando para $V_3$, que é um collider, induzimos correlação entre $Z$ e $T$ para a condição de relevância ser satisfeita, e $Z$ é uma VI candidata.



```{r dag-diagram2, echo=FALSE, message=FALSE}
dag_iv <- dagify(
  T ~ U1,
  V3 ~ T + Z,
  Y ~ T + U1,
  
  latent   = "U1",        # U não observado
  exposure = "T",
  outcome  = "Y",
  coords = list(
    x = c(Z = 0, T = 1, U1 = 1, V3 = 1, Y = 2),
    y = c(Z = 2, T = 2, U1 = 4, V3 = -1,Y = 2)
  )
)

# 2. Plotar o DAG:
ggdag(dag_iv, text = FALSE) +
  geom_dag_text(size = 5) +      # adiciona rótulos nos nós
  geom_dag_edges() +             # desenha as arestas
  theme_dag()                    # tema minimalista para DAG

```

Do mesmo jeito, se $V_3$ for causa comum de $Z$ e $T$, não controlar para ela torna a $Z$ admissível como VI.

```{r dag-diagram3, echo=FALSE, message=FALSE}
dag_iv <- dagify(
  T ~ U1 + V3,
  Z ~ V3,
  Y ~ T + U1,
  
  latent   = "U1",        # U não observado
  exposure = "T",
  outcome  = "Y",
  coords = list(
    x = c(Z = 0, T = 1, U1 = 1, V3 = 1, Y = 2),
    y = c(Z = 2, T = 2, U1 = 4, V3 = -1,Y = 2)
  )
)

# 2. Plotar o DAG:
ggdag(dag_iv, text = FALSE) +
  geom_dag_text(size = 5) +      # adiciona rótulos nos nós
  geom_dag_edges() +             # desenha as arestas
  theme_dag()                    # tema minimalista para DAG

```


Será que $Z$ pode ser uma IV no DAG abaixo? 

```{r dag-diagram4, echo=FALSE, message=FALSE}
# 1. Definir o DAG com coordenadas manuais
dag_complex <- dagify(
  T ~ U + W + L,        # T ← U, W, L
  Y ~ U,                # Y ← U
  L ~ W,                # L ← W
  Z ~ W + L,            # Z ← W, L
  latent   = "U",       # U é latente
  exposure = "T",
  outcome  = "Y",
  coords = list(
    x = c(U = 1.5, T = 1,   Y = 2,   Z = -2, W = 0, L = 0),
    y = c(U = 3,   T = 2,   Y = 2,   Z = 2,  W = 3, L = 1)
  )
)

# 2. Plotar com estilo de arestas (U→* tracejado)
ggdag(dag_complex, text = FALSE) +
  geom_dag_text(size = 5) +      # adiciona rótulos nos nós
  geom_dag_edges() +             # desenha as arestas
  theme_dag() 
```

Vamos verificar as condições. É fácil ver que $Z$ está conectado a $T$, já que temos dois caminhos abertos, um via $W$ e outro via $L$ (e ainda um via $W$ via $L$). Portanto, a primeira condição está satisfeita. Note que se eu controlar simultaneamente para $W$ e $L$, então eu fecho todos os caminhos abertos.

Com relação à segunda condição, Remover a flecha de $T$ para $Y$ é, efetivamente, ter um novo DAG:

Por fim, $Z$ não compartilha causa comum com $Y$.

Nesse DAG, $Z$ não está d-separado de $Y$, pois existe um caminho aberto para $Y$ via $L$. Portanto, controlando para $L$ (mas não $W$), tenho um instrumento que passa nas duas condições.

## IV com modelo estrutural

$y_i = \beta D_i + \delta_2 U + e_i$
$D_i = \delta_1 U + \gamma z_i + u_i$

As duas equações são estruturais, no sentido de que representam relações causais.
A restrição de exclusão do tratamento $D_i$ é que $\mathbb{E}[D_i|e_i] = 0$. Sabemos que não é verdade porque $D_i$ é endógeno, ou seja, há um viés de variável omitida, $U$. Já a restrição de exclusão da variável instrumental é que $\mathbb{E}[z_i|u_i] = 0$

Vamos supor, para simplificar, que tanto $D_i$ quanto $Z_i$ são binários. 

Considere o seguinte exemplo:

Nós sabemos que diferença simples de média identifica o ATE da segunda equação: $\gamma = \frac{\sum_{i=1}^n z_i}{n} - \frac{\sum_{i=1}^n (1-z_i)}{n}$.



## MQO em 2 Estágios

Considere novamente o DAG canônico para IV. Como poderíamos estimar o efeito causal de $T$ sobre $Y$?

Uma possibilidade é a chamada forma reduzida, que pode ser derivada a partir da suposição de independência. Antes, vamos introduzir uma notação:

A notação $Y^{T=t,Z=z}$ indica o resultado potencial para um nível do tratamento $t$ efetivamente recebido, que pode ser $0$ ou $1$, e para um nível do *treatment assignment*, que pode ser $0$ ou $1$, para um instrumento binário.

E também temos um status potencial do tratamento (em oposição ao tratamento observado): $T^1_i$ é o status do tratamento quando $Z=1$. Similarmente, $T^0_i$ é o status do tratamento quando $Z=0$.

E aqui temos uma nova *switching equation*:

$T_i = T^0_i + (T^1_i - T^0_i)Z_i$

\begin{align}
   E\big[Y_i\mid Z_i=1\big]-E\big[Y_i\mid Z_i=0\big] & = E\big[Y_i(D_i^1,1)\mid Z_i=1\mid]-
   E\big[Y_i(D_i^0,0)\mid Z_i=0\big]
   \\
                                    & = E[Y_i(D_i^1,1)] - E[Y_i(D_i^0,0)]  
\end{align}

O estimador é o efeito causal (total) de $Z$ sobre $Y$. Em um experimento, isso é chamado de *intent to treat*, pois se a aleatorização é o instrumento, então é o efeito causal da intenção de tratar. 


```{r sim-dag-canonico, message=FALSE, results='asis'}
library(stargazer)

n <- 100000

set.seed(123)
z <- rnorm(n)
u <- rnorm(n, 0 , 3)
treatment <- rbinom(n, 1, plogis(z - u + rnorm(n, 0, 2)))

y <- 2*treatment + u

reg_vies <- lm(y ~ treatment)
summary(reg_vies)

reg_1s <- lm(treatment ~ z)
reg_2s <- lm(y ~ fitted(reg_1s))
stargazer(reg_vies, reg_1s, reg_2s, type = "html",  title="OLS e 2SLS")
```

Uma regra de bolso, baseada em um artigo de Stock & Yogo (2002), diz que a estatística F da regressão do primeiro estágio deve ser maior que 10.

```{r sim-dag-canonico-n, cache=TRUE}
library(tidyverse)
library(ggplot2)

simulate_and_fit <- function(n) {
  z <- rnorm(n)
  u <- rnorm(n, 0, 3)
  treatment <- rbinom(n, 1, plogis(z - u + rnorm(n, 0, 2)))
  y <- 2 * treatment + u
  
  # Naive regression
  reg_vies <- lm(y ~ treatment)
  
  # 2SLS
  reg_1s <- lm(treatment ~ z)
  predicted_treatment <- predict(reg_1s)
  reg_2s <- lm(y ~ predicted_treatment)
  
  # Return coefficients
  tibble(
    naive_coef = coef(reg_vies)[2],
    tsls_coef = coef(reg_2s)[2]
  )
}


# Sample sizes to simulate
sample_sizes <- seq(1000, 100000, by = 1000)

# Use map to apply the function to each sample size
results <- tibble(sample_size = sample_sizes) %>%
  mutate(
    simulation_results = map(sample_size, simulate_and_fit)
  ) %>%
  unnest(cols = c(simulation_results))

results %>%
  pivot_longer(cols = c(naive_coef, tsls_coef), names_to = "method", values_to = "coefficient") %>%
  ggplot(aes(x = sample_size, y = coefficient, color = method)) +
  geom_line() +
  geom_smooth(data = . %>% filter(method == "2sls_coef"), method = "lm", se = FALSE, color = "red") +

  labs(
    title = "Convergence of Regression Coefficients with Increasing Sample Size",
    x = "Sample Size",
    y = "Estimated Coefficient",
    color = "Method"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("naive_coef" = "blue", "tsls_coef" = "red")) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_blank()
  )
```

## Principais usos de IV

### Experimentos

Quando pesquisadores utilizam o processo de assignment como instrumento para lidar com problema de non-compliance. Estimativas do Local Average Treatment Effect são críveis. Contraposição a intent-to-treat estimates.

### Regras com variação quasi-aleatória

Kin (2019) utiliza uma regra na Suécia que obriga cidades com poplução acima de certo nível a adotar democracia direta. Dinas (2014) utiliza idade para votar no momento da eleição como instrumento para comparecimento eleitoral do eleitor.

### Teoria

Quando a restrição de exclusão é baseada em teoria ou conhecimento substantivo. Aqui estão os instrumentos baseados em geografia ou clima (por exemplo, proximidade a faculdade como instrumento para ensino superior) ou (Zhu, 2017) que usou proximidade geográfica de cinco centros comerciais fora da China (ponderados pelo PIB dos centros comerciais) como instrumento para presença de multinacional (que causaria corrupção). Há o clássico instrumento de chuva como instrumento para, por exemplo, comparecimento eleitoral de eleitores democratas.

Mellon (2023) revisou 289 estudos e concluiu que 195 variáveis distintas foram conectadas com chuva, o que significa que podem ser potenciais violações da restrição de exclusão.

Cinelli and Hazlett

Freidman et. al (2000) usaram origem legal (francesa, inglesa, sueca etc.) como instrumento para qualidade das instituições. Djankov et al. (2003) usaram origem legal como instrumento para grau de formalismo de instituições.

Glaeser et al. (2004) usaram origem legal como instrumento para restrições ao executivo ("executive constraints").

Henderson and Brooks, 2016, usam chuva ao redor do dia da eleição como instrumento para votação de candidatos democratas, e concluem que aumento da chuva reduz comparecimento que causa democratas terem comportamento legislativo mais direitoso.

##Efeito heterogêneo


Se houver efeito heretogêneo (apenas mulheres mudam comportamento em razão do instrumento, por exemplo), então estamos estimando o efeito apenas para aquele subgrupo (são os compliers com o instrumento).

Se o instrumento explicar pouco da variação no Tratamento, então teremos pouca variação no tratamento para explicar a variação em Y. Ou seja, o sinal é fraco. Isso se traduz em baixo poder estatístico.

Para discutir efeito casual heterogêneo, vamos utilizar um estudo em ciência política (White, 2019). Qual o efeito de misdemeanor (algo como contravenção penal) sobre comparecimento eleitoral? O aturo argumenta que o efeito deve variar por raça (maior para negros que brancos), de modo que o efeito causla é heterogêneo. Segundo o autor, casos são atribuídos aleatoriamente para diferentes cortes judiciais, e elas variam em sua leniência (ou severidade). Aqui, o tratamento é a condenação ($1$ se condenado, $0$ se não), e temos uma variável instrumental, o sorteio do juiz mais ou menos leniente.

Alguns acusados têm tantas evidências que serão condenados não importa para que tipo de corte são enviados. Outros, podem sersempre absolvidos, não importa o juiz. Há os !azarados", que só serão condenados se enviados para a corte severa. O que não faz sentido é ter alguém que só é condenado se enviado para um juiz leniente e absolvido se enviado para um severo.
Nós iremos agrupar esses quatro tipos (incluindo o último) em quatro tipos:

Os primeiros são chamado de always-takers. Sempre recebem o tratamento (são presos), não importa o que foi atribuído a eles pelo mecanismo de atribuição. O segundo são os never takers, que nunca recebem o tratamento. Por fim, o terceiro grupo são os compliers, que seguem o tratamernto prescrito e o quarto grupo são os defiers, aqueles que fazem o contrário do prescrito. Nesse caso, não faz muito sentido imaginar que existem os defiers, mas teoricamente é possível.

Digmos que o efeito causal do tratamento é heterogêneo, isto é, $\delta_i = Y^1_i - Y^0_i$.

Nesse caso, não podemos mais estimar o efeito causal geral (ATE), pois o efeito causla é heterogêneo e o instrumento só explica a variação no tratamento para os compliers.

### Suposições para estimar o LATE

Além das suposições que já discutimos, vale sempre lembrar que temos também a SUTVA.

Resultados potenciais para unidade $i$ não estão relacionadas ao tratamento que $j$ recebe. Claramente existe potencial para SUTVA ser violada no estudo de encarceramento e voto. Se dois irmãos (indivíduo $i$ e $j$) são acusados e um deles é preso, é possível que o tratamento de um deles impacte a probabilidade de voto do outro e vice-versa. Salvo engano, White não discute essa possibilidade de violação da suposição, o que é problemático. Mas vamos supor que SUTVA está garantido.

2. Vale lembrar também que Independência é diferetne da restrição de exclusão

Também chamada de *as good as random assignment* e *no confounding for the effect of Z on Y*. Afirma que a IV é independente dos resultados potenciais e das potenciais atribuições de tratamento. Em termos de nosso DAG, quer dizer que $Z$ não compartilha causa comum com $Y$. 

Essa suposição parece tranquilamente satisfeita no estudo em questão, já que a atribuição da corte é aleatória e parece difícil imaginar que algo que causa a leniência da corte ser causado por alguma variável que também causa o comparecimento. Aqui o DAG:

## Restrição de Exclusão

## Monoticidade

Por fim, precisamos assumir monoticidade. Ela requer que a variável instrumental opera (fracamente) em todas as direções para todos os indivíduos. Ou seja, todo mundo que é afetado pelo instrumento é afetado da mesma maneira. Em outras palavras, o instrumento apenas move as pessoas do controle para o tratamento (ou não move a pessoa), mas nunca o contrário. Ou seja, estamos assumindo que não há defiers na nossa população.

Matematicamente e de maneira geral, dizemos que a monoticidade é válida quando $T^{Z=1} >= T^{Z=0}$ para todas as unidades.

Com essas suposições, nós estiamos o LATE: Local Average Treatment Effect of T on Y. Isso porque nosso estimador é:

\begin{align}
  \mathbb{E}[Y(Z=1) - Y(Z=0)] = \\
  =& \mathbb{E}[Y(Z=1) - Y_i(Z=0)|T^1 = 1, T^0 = 1]P(T^1 = 1, T^0 = 1) \text{ always-takers} \\
  +& \mathbb{E}[Y(Z=1) - Y_i(Z=0)|T^1 = 0, T^0 = 0]P(T^1 = 0, T^0 = 0) \text{ never-takers} \\
  +& \mathbb{E}[Y(Z=1) - Y_i(Z=0)|T^1 = 1, T^0 = 0]P(T^1 = 1, T^0 = 0) \text{ compliers} \\
  +& \mathbb{E}[Y(Z=1) - Y_i(Z=0)|T^1 = 0, T^0 = 1]P(T^1 = 0, T^0 = 1) \text{ defiers}
\end{align}

Porém, sabemos que o instrumento não tem efeito causal sobre always-takers nem never-takers, então o efeito causal é zero para esses grupos. E a proporção de defiers é zero, de modo que ficamos apenas com a parte dos compliers. E nesse grupo, $Z = T$, de modo que o efeito do instrumento é o efeito do tratamento. Então podemos reescrever como:


$$\delta_{IV,LATE} = \mathbb{E}[Y(1) - Y^0)|T^1 - T^0 = 1]$$

Vejam que o denominador nos dá a proporção da população que mudou seu status por causa do instrumento.

## Estimação (aka estatística F)

Considere nosso modelo em que as variáveis estão centradas (sem constante) e não há controle.

$y_i = \beta D_i + e_i$
$D_i = \pi z_i + u_i$

Posso reescrever a equação de resultado como:

$y_i = \beta (\pi z_i + u_i) + e_i =  \underbrace{\beta \pi}_{\delta} z_i + \beta u_i + e_i$
Essa equação é chamada de forma reduzida.

Lembrando que nosso estimador $\hat{\beta}_{2sls} = \frac{\hat{\delta}}{\hat{\pi}}$

Ou seja, o estimador de 2sls é a razão da forma reduzida e o primeiro estágio

O que acontece se $Cov(D_i, z_i)$ for muito pequeno? Pequenas variações podem impactar bastante as estimativas.

É possível mostrar (supondo homocedasticidade) como o viés do nosso estimaodr em dois estágio se releciona com a estatística F:

$$
\mathbb{E}[\hat{\beta_{2sls}} - \beta] \approx \underbrace{\frac{Cov(u,e)}{Var(u)}}_{\text{OVB}} \frac{k}{F + 1}
$$

Se a estatística F é zero, ou seja, o poder do teste é zero, então o viés é igual ao de MQO normal, ou seja, a estimativa com IV é a mesma de OLS/MQO.

Quanto maior a estatística F, menor o viés. E por fim, quanto maior o número de instrumentos (isso não está explícito, mas entra na fórmula), maior o viés em amostras finitas.

É por essa razão que a literatura se concentrou em uma heurística para a estatística F, que vimos é ser maior que 10. Que basicamente é dizer que será no máximo 10% do viés com 95% de certeza.




### F stat

A estatística F do primeiro estágio é a parcela explicada no primeiro estágio, relativo ao ruído no primeiro estágio. Quanto maior a estatística F, menor o viés.

Se o poder é zero, $F = 0$ e IV é apenas a estimativa de MQO.

Ponto chave: quando existem muitos instrumentos, o viés aumenta.

This is the approach initially developed by Staiger and Stock (1997) and Stock and Yogo (2005).
- Typical rule of thumb: first-stage F-statistic above 10 means that bias won’t be larger than 10% with size of 5%. Very popular!
- Suposição chave: homecedasticidade!

Montiel Olea and Pfluger( 2013) desenvolveram um teste robusto a heterocedasticidade, com uma estatística F mais apropriada  a (allows for clustering, autocorrelation, etc.)
- O novo ponto de corte é mais como 23.1

O patoce ivDiag computa essa estatística F. Função eff_F. 

Alternativa é computar um invervalo de confiança de Anderson-Rubin, que é válido mesmo com instrumento fraco. Novamente, ivDiag computa esse IC.  


## Referências

Henderson, J., & Brooks, J. (2016). Mediating the electoral connection: The information effects of voter signals on legislative behavior. The Journal of Politics, 78(3), 653-669.

Mellon, J. (2023). Rain, Rain, Go Away: 195 Potential Exclusion-Restriction Violations for Studies Using Weather as an Instrumental Variable. Available at SSRN 3715610.

White, A. (2019). Misdemeanor disenfranchisement? The demobilizing effects of brief jail spells on potential voters. American Political Science Review, 113(2), 311-324.

<!--chapter:end:06-VI.Rmd-->

# Desenho de Regresão Discontínua

## Outline da aula

Na aula de hoje, iremos aprender sobre identificação causal do do aspecto mais simples da RD e como funciona

Em seguida, estimação e checagem. Falaremos rapidamente de extensões.

## Características-chave da RDD

A Regressão Discontínua (RDD) é caracterizada por uma variável contínua $X_i$, que determina quem recebe tratamento, denotado por $T_i$ (1 se tratado). Por convenção, $X$ é chamada de "running variable", "assignment variable" ou "forcing variable".

### Determinação do Tratamento

Em um desenho RDD *sharp*, uma unidade é tratada se $X_i \geq c$ e não tratada se $X_i < c$. Assim, $T_i$ é uma função determinística de $X_i$: $T_i = f(X_i)$. A *running variable* determina completamente quem recebe tratamento.

## Fuzzy RDD

- Pode acontecer do ponto de corte não determinar quem recebe ou não o tratamento, mas apenas a probabilidade de receber o tratamento.

- Nesse caso, a regra serve como variável instrumental ao redor do ponto de corte.

- Ex.: regra de voto determina número de cadeiras. Mas migração partidária altera o número. Então quem fica abaixo do número mínimo em um distrito pode ter cadeiras naquele distrito via migração partidária.

### Observação e Corte

É essencial observar $X$ e conhecer o **ponto de corte** ou **limiar** $c$.

Uma das suposições da RDD é que ela requer a continuidade da variável $X$ para identificação, embora, na prática, alguns estudos de RDD tenham usado *running variables* discretas. A continuidade de $X$ é necessária porque a identificação ocorre no limite.

Mas a suposiçao chave é que os resultados potenciais devem ser contínuos ao redor do ponto de corte. Como sempre, essa suposição é intestável, devido ao problema fundamental da inferência causal. Lee (2008), em um artigo clássico, mostrou que uma condição mais restritiva é suficiente para identificação causal: que as unidades podem controlar a running varibale, exceto ao redor do ponto de corte. Isso implica também que as covariáveis de pré-tratamento são contínuas no cutoff. Isso é potencialmente testável, pelo menos nas variáveis observadas e em geral olhando para a média das variáveis, o que não é a mesma coisa que olhar para outros momentos, que podem ser descontínuos.

### Estimativa dos Efeitos do Tratamento

A comparação de $\lim_{x \uparrow c} E[Y_i | X_i = x]$ com $\lim_{x \downarrow c} E[Y_i | X_i = x]$ fornece uma estimativa dos efeitos do tratamento (note a direção das setas).

Esta comparação é equivalente a: $\lim_{x \uparrow c} E[Y_i | X_i = x, T_i=0]$ e $\lim_{x \downarrow c} E[Y_i | X_i = x, T_i=1]$, uma vez que, neste exemplo, à direita de $c$ todos recebem tratamento; à esquerda, ninguém recebe. Portanto:

- $\lim_{x \uparrow c} E[Y_i | X_i = x] \approx E[Y_{0i} | X_i = c]$
- $\lim_{x \downarrow c} E[Y_i | X_i = x] \approx E[Y_{1i} | X_i = c]$

Se fôssemos usar regressão linear, o modelo seria:
$y_i = \alpha + \beta_1 (x_i > c) + \beta_2 x_i + \beta_3 x (x_i > c) + e_i$, em que $c$ é o ponto de corte, e $x$ é a *running variable*.

## Suposição de continuidade

- A suposição de continuidade é tão crítica que vale discutirmos um pouco mais sobre ela.
- Se há continuidade, isso significa que, na auência do ponto de corte $c$, x (e outras covariáveis) não devem apresentar descontinuidade.
- Ex.: Suponha que estamos interessados em estudar o efeito da incumbência sobre a chance de reeleição futura ou riqueza futura desses políticos.
- Habilidades e carisma são variáveis que devem influenciar tanto a chance de serem incumbentes como os resultados de interesse. Em um RDD, podemos usar *close elections* para estimar o efeito. E a suposição de continuidade requer que carisma e habilidades não tenham descontinuidade no *cut off* de 50%. Na verdade, apenas o resultado eleitoral é descontínuo no *cut off*, que vai de não-eleito para eleito.

## Suposições na RDD

### Suposição de Não-manipulação com Precisão

A identificação dos efeitos do tratamento na RDD baseia-se na premissa de que $X$ atua como um aleatorizador ao redor de $c$. Imagine que $X$ seja uma variável aleatória uniforme usada para atribuir tratamento. Se $X \geq c$, uma unidade recebe tratamento. Na RDD, $X$ tem o mesmo papel, exceto que não assumimos que $X$ é independente do resultado $Y$. Na maioria das aplicações, $X$ e $Y$ são correlacionados de alguma forma.

### Problemas de Manipulação

No entanto, se $c$ não for arbitrário ou tiver uma relação determinística com $Y$, ou se as unidades puderem — com precisão — determinar seus escores $X$ e, assim, escolher receber tratamento ou não, então $X$ ao redor de $c$ não se comporta mais como um aleatorizador — há alguma forma de auto-seleção que poderia depender de variáveis não observáveis.

## Testabilidade da Suposição de não-Manipulação

Em parte, isso é testável. As unidades não pareceriam semelhantes perto de $c$ e haveria um "acúmulo" próximo a $c$. No entanto, não podemos descartar a manipulação com precisão apenas com dados — devemos argumentar isso com conhecimento do assunto (é uma restrição de exclusão).

## Estimação em RDD

### Problema de Complete Overlapping

Um problema chave na estimação em RDD estrita é a completa falta de sobreposição.

Em matching, dicustimos como a ausência de sobreposição gerava problemas de extrapolação.

Sobreposição requer que $0 < P(D_i = 1 | X_i) < 1$ para o domínio de $X_i$. No domínio da *running vairable* $X_i$, isso claramente não é satisfeito. Em RDD estrita, temos $P(D_i = 1 | X_i < c) = 0$ e $P(D_i = 1 | X_i \geq c) = 1$.

### Dependência de Extrapolação

Devido à falta de sobreposição, dependemos de extrapolação para estimar os efeitos do tratamento. Dito de outra forma, podemos não ser capazes de estimar corretamente os efeitos do tratamento se errarmos a forma funcional $Y_i = f(X_i)$. Novamente, essa foi uma motivação para usar matching. 

O problema é que nunca sabemos se acertamos, então a especificação do modelo é uma questão chave na estimação RDD.

## Métodos de Estimação

O problema sugere a necessidade de um método de estimação não paramétrico. Utilizaremos métodos paramétricos, não paramétricos (ou semiparamétricos) para tentar abordar essas questões.

### Identificação no Limite

A identificação dos efeitos do tratamento ocorre no limite, à medida que $X_i \rightarrow c$. Quanto mais usarmos observações distantes de $c$ em $X$, mais dependeremos de extrapolação e das suposições sobre a forma funcional.

## Trade-off de Viés-Variância

- **Mais perto de c:** Melhor em termos de precisão, mas pode haver uma amostra insuficiente. Resulta em menos viés, mas mais variância.
- **Mais distante de c:** Dependemos menos de extrapolação, mas introduzimos mais viés, mesmo com menor variância.

### Métodos de Largura de Banda Ótima

A ideia é restringir a estimativa a uma janela ao redor de $X_i = c$, que pode ter tamanhos diferentes à esquerda ou à direita. Estes métodos buscam equilibrar a precisão das estimativas minimizando viés e variância conforme a proximidade do ponto de corte $c$.

## Regras arbitrárias

Atribuição de "coisas" a partir de regras com pontos de cortes

Bolsa família: a partir de certa renda

Educação: aprovação no ensino superior a partir de certa nota de corte

Espacial: polítia pública para donos de áreas abaixo ou acima de certas áreas.

Data: regras para aposentadoria, idade para entrar na escola, data para perdão de dívida: Desenrola: "...cujas dívidas tenham sido incluídas no cadastro de inadimplentes no período entre 1º de janeiro de 2019 e 31 de dezembro de 2022".

Política: regras de número de vereadores, regras de população para ter segundo turno, regras para ter biometria etc.

## Simulação

```{r}
## Basic RD Model
set.seed(123)
N <- 1000 # number of observations
X <- runif (N , -5,5)
Y0 <- rnorm ( n =N , mean =X , sd=1) # control potential outcome
Y1 <- rnorm ( n =N , mean = X+2, sd=1) # treatment potential outcome
#You only get treatment if X>0
Treatment <- ( X >= 0)
# What we observe
Y = Y1* Treatment + Y0*(1- Treatment )
```


```{r, echo=FALSE, warning=FALSE, message=FALSE}
## Basic RD Model
library(ggplot2)
library(tidyverse)

# df
df <- data.frame(y=Y, x=X, treatment = Treatment, y0 = Y0, y1=Y1)
df_aux <- df
```

```{r plot-treatment-assignment, echo=FALSE}
df %>%
  ggplot(aes(x=x, y=treatment)) + geom_line() +
  labs(x = "running variable", y = "Treatment") +
  theme_minimal()  
```

## Simulação - Potential Outcomes Y0


```{r plot-po-y0, echo=FALSE}
df %>%
  ggplot(aes(x=x, y=y0, colour=treatment)) + geom_point() +
  labs(x = "running variable", y = "Potential Outcome Y0") +
  scale_colour_manual(values = c("black", "red")) +
  theme_minimal() +
  theme(legend.position = "none")

```

## Simulação - Potential Outcomes Y1


```{r plot-po-y1, echo=FALSE}

df %>%
  ggplot(aes(x=x, y=y1, colour=treatment)) + geom_point() +
  labs(x = "running variable", y = "Potential Outcome Y1") +
  scale_colour_manual(values = c("green", "blue")) +
  theme_minimal() +
  theme(legend.position = "none")

```

## Simulação - Potential Outcomes Y1 e Y0


```{r plot-po-y1-Y0, echo=FALSE, message=FALSE}
df_long <- df %>%
  pivot_longer(
    cols = c("y0", "y1"),
    names_to = "outcome_type",
    values_to = "outcome"
  )
df_long_aux <- df_long

ggplot(df_long, aes(x = x, y = outcome, colour = interaction(treatment, outcome_type))) +
  geom_point() +
  scale_colour_manual(values = c("FALSE.y0" = "black", "TRUE.y0" = "red",
                                 "FALSE.y1" = "green", "TRUE.y1" ="blue")) +
  labs(x = "Running Variable", y = "Potential Outcome") +
  theme_minimal() +
  theme(legend.position = "none")

df_long %>%
  ggplot(aes(x=x, y=outcome, group = outcome_type)) + geom_smooth(se=FALSE) +
  geom_vline(xintercept = 0)  +
  scale_color_manual(values = c(
    "y0" = "blue",
    "y1" = "red"
  ))
```

## Simulação - Y observado
```{r plot-observed, echo=FALSE}

ggplot(df, aes(x = x, y = y, colour = treatment)) +
  geom_point() +
  scale_colour_manual(values = c("black", "blue")) +
  labs(x = "Running Variable", y = "Resultados observados - Y") +
  theme_minimal() +
  theme(legend.position = "none")
```

## Quando o RDD funciona?

A suposição chave para o RDD é que tenha descontinuidade ao redor do ponto de corte, e que não haja descontinuidade ao redor do ponto de corte em outra variável omitida. Vamos ver o que isso significa, comparando quator gráficos, três em que a estimativa do RDD é válida, mas com diferentes validades "externas" e uma em que é inválida.

```{r multiplos_rdds, echo=FALSE, message=FALSE}
library(rdrobust)
set.seed(123)
N <- 1000 # number of observations
U <- rnorm(N)
X <- runif (N , -5,5) - U
X <- X - mean(X)
Y0 <- rnorm ( n =N , mean =X , sd=2) + 2*U^2  # control potential outcome
Y1 <- Y0 + 2 + 2*U^2  # treatment potential outcome
#You only get treatment if X>0
Treatment <- ( X >= 0)
# What we observe
Y = Y1* Treatment + Y0*(1- Treatment )
mean(Y1 - Y0)
df <- data.frame(y=Y, x=X, treatment = Treatment, y0 = Y0, y1=Y1)


df_long <- df %>%
  pivot_longer(
    cols = c("y0", "y1"),
    names_to = "outcome_type",
    values_to = "outcome"
  )

df_long %>%
  ggplot(aes(x=x, y=outcome, group = outcome_type, colour = outcome_type)) + geom_smooth(se=FALSE) +
  geom_vline(xintercept = 0) +
  scale_color_manual(values = c(
    "y0" = "blue",
    "y1" = "red"
  ))
# 2

Y0 <- rnorm ( n =N , mean =X , sd=1) + .5*U^2 - X*U # control potential outcome
Y1 <- Y0 + 2 + 2*X*U # treatment potential outcome
#You only get treatment if X>0
Treatment <- ( X >= 0)
# What we observe
Y = Y1* Treatment + Y0*(1- Treatment )
mean(Y1 - Y0)
df <- data.frame(y=Y, x=X, treatment = Treatment, y0 = Y0, y1=Y1, u = U)
df_u <- df

df_long <- df %>%
  pivot_longer(
    cols = c("y0", "y1"),
    names_to = "outcome_type",
    values_to = "outcome"
  )

df_long %>%
  ggplot(aes(x=x, y=outcome, group = outcome_type, colour = outcome_type)) + geom_smooth(se=FALSE) +
  geom_vline(xintercept = 0) +
  scale_color_manual(values = c(
    "y0" = "blue",
    "y1" = "red"
  ))


# 3
Y0 <- rnorm ( n =N , mean =X , sd=1) + U^2   # control potential outcome

Y1 <- Y0 + 2 - 1.5*U^3 # treatment potential outcome
#You only get treatment if X>0
Treatment <- ( X >= 0)
# What we observe
Y = Y1* Treatment + Y0*(1- Treatment )

df <- data.frame(y=Y, x=X, treatment = Treatment, y0 = Y0, y1=Y1)


df_long <- df %>%
  pivot_longer(
    cols = c("y0", "y1"),
    names_to = "outcome_type",
    values_to = "outcome"
  )

df_long %>%
  ggplot(aes(x=x, y=outcome, group = outcome_type, colour = outcome_type)) + geom_smooth(se=FALSE) +
  geom_vline(xintercept = 0) +
  scale_color_manual(values = c(
    "y0" = "blue",
    "y1" = "red"
  ))


# 4
f0 <- function(x) {  sin(x) * 1.5  - 0.1 * x    }       # E[Y(0)|X]
f1 <- function(x) {  f0(x)   +  0.5 * x      }          # E[Y(1)|X], so f1(0)=f0(0)

# 2. Build a long data.frame, tagging where each is observed
x_seq <- seq(-5, 5, length.out = 400)
df0 <- data.frame(x = x_seq, y = f0(x_seq), type = "E[Y(0)|X]")
df1 <- data.frame(x = x_seq, y = f1(x_seq), type = "E[Y(1)|X]")

df <- rbind(df0, df1)

# 3. Plot
ggplot(df, aes(x = x, y = y, color = type)) +
  geom_line(size = 1.2) +
  scale_color_manual(values = c(
    "E[Y(0)|X]" = "blue",
    "E[Y(1)|X]" = "red"
  ))

# 5
Y0 <- rnorm ( n =N , mean =X , sd=1)    # control potential outcome
m <- length(X[X < .4 & X > -.4])
Y1 <- Y0 + 2 # treatment potential outcome
Y0[X < .4 & X > -.4] <- rnorm(m , 2, sd = .3)
Treatment <- ( X >= 0)
# What we observe
Y = Y1* Treatment + Y0*(1- Treatment )

df <- data.frame(y=Y, x=X, treatment = Treatment, y0 = Y0, y1=Y1)

df <- data.frame(y=Y, x=X, treatment = Treatment, y0 = Y0, y1=Y1, u = U)


df_long <- df %>%
  pivot_longer(
    cols = c("y0", "y1"),
    names_to = "outcome_type",
    values_to = "outcome"
  )

df_long %>%
  ggplot(aes(x=x, y=outcome, group = outcome_type, colour = outcome_type)) + geom_smooth(se=FALSE) +
  geom_vline(xintercept = 0) +
  scale_color_manual(values = c(
    "y0" = "blue",
    "y1" = "red"
  ))

ggplot(df, aes(x = x, y = y, colour = treatment)) +
  geom_point() +
  scale_colour_manual(values = c("black", "blue")) +
  labs(x = "Running Variable", y = "Resultados observados - Y") +
  theme_minimal() +
  theme(legend.position = "none")

# mean(df$y1 - df$y0)
# mean(Y1 - Y0)
# basic_model <- rdrobust(y = df$y, x = df$x, c = 0)
# summary(basic_model)
# summary(lm(y ~ x, data=df))
# library(rdrobust)
rdplot(y=df$y, x=df$x, binselect = "qs")

```




## Raw Data versus Bin

```{r plot-binscatter, echo=FALSE}
df <- df_aux
df_long <- df_long_aux
ggplot(df, aes(x = x, y = y, color = treatment)) +
  stat_summary_bin(
    fun = mean,        # calcula a média de Y_cont em cada bin
    bins = 40,         # número de bins
    geom = "point",    # plota um ponto para cada bin
    size = 2
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    x     = "Variável de corte (X)",
    y     = "Média de Y",
    color = "Grupo",
    title = "Binscatter: médias nos bins em vez de dados brutos"
  ) +
  theme_minimal()
```

Como escolher os bins?
1. Espaçamentos iguais ou quantis?
2. Quantos bins?

No exemplo, escolhi espaçamento igual e 20 bins. Podemos usar quantis.
```{r plot-binscatter-quantis, echo=FALSE}
df2 <- df %>%
  mutate(bin = ntile(x, 40)) %>%           # 20 quantis
  group_by(bin, treatment) %>%
  summarize(
    x = mean(x),                           # posição média de x no bin
    y = mean(y),                           # média de y no bin
    .groups = "drop"
  )

ggplot(df2, aes(x = x, y = y, color = treatment)) +
  geom_point(size = 2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    x     = "Variável de corte (X)",
    y     = "Média de Y (por quantil)",
    color = "Grupo",
    title = "Binscatter com bins por quantis"
  ) +
  theme_minimal()
```

Não faz muita diferença neste exemplo, mas usar quantis é mais transparente e mais crível retoricamente, pois não mascara a densidade.

Sobre o número de bins, Cattaneo et. al (2020) discutem o tema e sugerem duas abordagens: 
1. IMSE-minimizing (proporcional a $n^{1/3}$)
2. Mimmicking-variance (proporcional a $n/log(n)^2$)

E usamos o pacote rdplot para implementar isso automaticamente

```{r plot-binscatter-quantis-rdplot-qs, echo=FALSE}
library(rddensity)
library(rdrobust)
rdplot(y=df$y, x=df$x, binselect = "qs")
```

```{r plot-binscatter-quantis-rdplot-qsmv, echo=FALSE}

rdplot(y=df$y, x=df$x, binselect = "qsmv")
```

## Permutation tests (balancing)

Para checar balancing, podemos usar testes de permutação.

```{r permutation-test, echo=TRUE, message=FALSE}
library(RATest)
df <- df_u
head(df)
resultado <- RDperm(
  W = "u",  # Substitua pelos nomes das suas covariáveis
  z = "x",              # Substitua pelo nome da sua variável de corte
  data = df,                # Substitua pelo seu data frame
  cutoff = 0                            # Substitua pelo valor do ponto de corte, se diferente de 0
)
summary(resultado)

plot(resultado, w="u", "cdf")
```

Canay& Kamat (2018) utiolizaram esse teste pars revisitar o trabalho de Lee (2008) e descobrem que havia problema de balanceamento.

Caughey and Sekhon (2011) na political analysis mostraram que de fato havia problemas de balanceamento no estudo de Lee (2008).



Do paper da PA:

```{r quote, echo=FALSE}

knitr::include_graphics("/Users/manoelgaldino/Documents/DCP/Cursos/Causalidade/Causalidade/imagens/quote.png")

knitr::include_graphics("/Users/manoelgaldino/Documents/DCP/Cursos/Causalidade/Causalidade/imagens/quote2.png")
```

Houve um debate na ciência política sobre isso.  Erikson & Rader (2017) e Cuesta & Imai (2016) argumentam que o RDD é identificado. Até onde eu sei, cientistas políticos não revisitaram a controvérsia com os novos metodos desenvolvidos pelos economistas.

De todo modo, as evidências de De Magalhães et. al (2025) sugerem que a recomendação que estou adotando no curso de quais práticas usar são as melhores e mais robustas.



## McCray test

Um dos principais desafios à identificação causal em RDDs é a possibilidade de manipulação por parte dos agentes sobre ficar acima ou abaixo do ponto de corte. A lógica esperada é que se o tratamento é desejável, indivíduos tentarão receber o tratanto, levando a um gap justamente abaixo do ponte de corte. Se o tratamento é indesejável (efeitos negativos), indivíduos vão evitar o tratamento, levando a um gap justamente acima do ponto de corte.

O exemplo mais evidente para nós cientistas políticos é a aprovação de um projeto de lei no legislativo. Nós sabemos que os legisladores agem estrategicamente retirando propostas que não vão ser aprovadas ou postergando a votação, até terem a maioria, ainda que por margem mínima. Nesse caso, a aplicação de RDD nesse caso produirá estimativas viesadas. McCray, em um artigo de 2008, argumentou que tais casos apareceriam como descontinuidade na densidade da *running variable* ao redor do ponto de corte. Eis o gráfico feito por McCray em seu estudo original:

```{r McCay-test, echo=FALSE}

knitr::include_graphics("/Users/manoelgaldino/Documents/DCP/Cursos/Causalidade/Causalidade/imagens/manipulation test.png")
```

Para formalizar essa ideia, McCray estima os limites da densidade pela esquerda e pela direita e avalia se a diferença (do logaritmo) das estimativas é estatisticamente significante diferente de zero. Portanto, rejeitar a hipótese nula é encontrar evidências de que há manipulação.  Cattaneo, Jansson, & Ma 2018; 2020 introduziram uma versão alternativa do teste, com espírito similar.

Na prática, de um ponto de vista retórico, o que pesquisadores querem é falhar em rejeitar a nula. Como o teste tem baixo poder de rejeitar a nula, ausência de evidência não quer dizer evidência de ausência.

```{r McCay-test1, message=FALSE}
library(rdd)
# Simulated data without discontinuity

DCdensity(df$x, 0)  # No discontinuity

```

Cattaneo Density Test (Improved Version)

```{r Cattaneo-test, message=FALSE}
library(rddensity)

# Simulated continuous density
rdd <- rddensity(X = df$x, vce = "jackknife")
summary(rdd)
```

Essa é uma área ativa de pesquisa, com novos testes sendo desenvolvidos, por exemplo, Fitzgerald (2025), que é um working paper.


## Robustez

Mostrar várias estimativas, para várias escolhas de estimações (bandwith etc.)

Uma possibilidade é simplesmente apresentar várias estimativas, como faremos abaixo. Ou então, uma tabela. Mas o mais simples seria um gráfico dos efeitos com seus respectivos ICs, em que cada entrada no eixo x é uma estimação, e no y temos o efeito.
Abaixo apresento duas dessas possbilidades para ilustrar como a última é a melhor.

```{r plot-estimator-1, echo=FALSE, message=FALSE, warning=FALSE}

# Calculate means for each treatment group
mean_values <- df_long %>%
  group_by(treatment) %>%
  summarise(mean_y = mean(y, na.rm = TRUE))

# Extract means for annotations
mean_black <- mean_values$mean_y[mean_values$treatment == FALSE]
mean_blue <- mean_values$mean_y[mean_values$treatment == TRUE]

# Calculate the difference (RDD estimator)
basic_model <- rdrobust(df$y, df$x, p=1)
rdd_estimate <- basic_model$coef[1]
vec_estimate <- rdd_estimate
se_estimate <- basic_model$se[2]


# Define the position for the bracket and text
bracket_height <- max(mean_black, mean_blue) + abs(mean_blue - mean_black)*0.001 
mid_y <- mean(mean_black, mean_blue)  # Midpoint between means for text

# Create the plot
ggplot(df_long, aes(x = x, y = y, colour = treatment)) +
  geom_point() +
  scale_colour_manual(values = c("black", "blue")) +
   geom_segment(aes(x = min(x), xend = 0, y = mean_black, yend = mean_black), colour = "black") +
  geom_segment(aes(x = 0, xend = max(x), y = mean_blue, yend = mean_blue), colour = "blue") +
  labs(x = "Running Variable", y = "Resultados observados - Y") +
  theme_minimal()  +  
  theme(legend.position = "none") +
  geom_segment(aes(x = 0, y = mean_black, xend = 0, yend = bracket_height), colour = "black") +
  geom_segment(aes(x = 0, y = mean_blue, xend = 0, yend = bracket_height), colour = "blue") +
  annotate("text", x = 1.5, y = mid_y, label = paste("RDD Estimator: ", round(rdd_estimate, 2), "-5 < x < 5"), 
           size = 5, colour = "red", vjust = -1)
```

```{r plot-estimator2, echo=FALSE, message=FALSE, warning=FALSE}

df_long <- df_long %>%
  filter ( x > -1 & x < 1)
# Calculate means for each treatment group
mean_values <- df_long %>%
  group_by(treatment) %>%
  summarise(mean_y = mean(y, na.rm = TRUE))

# Extract means for annotations
mean_black <- mean_values$mean_y[mean_values$treatment == FALSE]
mean_blue <- mean_values$mean_y[mean_values$treatment == TRUE]

# Calculate the difference (RDD estimator)
basic_model <- rdrobust(df$y, df$x, p=1, h=1)
rdd_estimate <- basic_model$coef[1]
vec_estimate[2] <- rdd_estimate
se_estimate[2] <- basic_model$se[2]

# Define the position for the bracket and text
bracket_height <- max(mean_black, mean_blue) + abs(mean_blue - mean_black)*0.001
mid_y <- mean(mean_black, mean_blue)  # Midpoint between means for text


# Create the plot
ggplot(df_long, aes(x = x, y = y, colour = treatment)) +
  geom_point() +
  scale_colour_manual(values = c("black", "blue")) +
   geom_segment(aes(x = min(x), xend = 0, y = mean_black, yend = mean_black), colour = "black") +
  geom_segment(aes(x = 0, xend = max(x), y = mean_blue, yend = mean_blue), colour = "blue") +
  labs(x = "Running Variable", y = "Resultados observados - Y") +
  theme_minimal()  + 
  theme(legend.position = "none") +
  geom_segment(aes(x = 0, y = mean_black, xend = 0, yend = bracket_height), colour = "black") +
  geom_segment(aes(x = 0, y = mean_blue, xend = 0, yend = bracket_height), colour = "blue") +
  annotate("text", x = .5, y = mid_y, label = paste("RDD Estimator: ", round(rdd_estimate, 2), "-1 < x < 1"), 
           size = 5, colour = "red", vjust = -1) 

```


```{r plot-estimator3, echo=FALSE, message=FALSE, warning=FALSE}

df_long <- df_long %>%
  filter ( x > -.5 & x < .5)
# Calculate means for each treatment group
mean_values <- df_long %>%
  group_by(treatment) %>%
  summarise(mean_y = mean(y, na.rm = TRUE))

# Extract means for annotations
mean_black <- mean_values$mean_y[mean_values$treatment == FALSE]
mean_blue <- mean_values$mean_y[mean_values$treatment == TRUE]

# Calculate the difference (RDD estimator)
basic_model <- rdrobust(df$y, df$x, p=1, h=.5)
rdd_estimate <- basic_model$coef[1]
vec_estimate[3] <- rdd_estimate
se_estimate[3] <- basic_model$se[2]


# Define the position for the bracket and text
bracket_height <- max(mean_black, mean_blue) + abs(mean_blue - mean_black)*0.001 
mid_y <- mean(mean_black, mean_blue)  # Midpoint between means for text


# Create the plot
ggplot(df_long, aes(x = x, y = y, colour = treatment)) +
  geom_point() +
  scale_colour_manual(values = c("black", "blue")) +
  geom_segment(aes(x = min(x), xend = 0, y = mean_black, yend = mean_black), colour = "black") +
  geom_segment(aes(x = 0, xend = max(x), y = mean_blue, yend = mean_blue), colour = "blue") +
  labs(x = "Running Variable", y = "Resultados observados - Y") +
  theme_minimal()  + 
  theme(legend.position = "none") +
  geom_segment(aes(x = 0, y = mean_black, xend = 0, yend = bracket_height), colour = "black") +
  geom_segment(aes(x = 0, y = mean_blue, xend = 0, yend = bracket_height), colour = "blue") +
  annotate("text", x = .1, y = mid_y, label = paste("RDD Estimator: ", round(rdd_estimate, 2), "-.5 < x < .5"), 
           size = 5, colour = "red", vjust = -1) 

```


```{r plot-estimator4, echo=FALSE, message=FALSE, warning=FALSE}

df_long <- df_long %>%
  filter ( x > -.1 & x < .1)
# Calculate means for each treatment group
mean_values <- df_long %>%
  group_by(treatment) %>%
  summarise(mean_y = mean(y, na.rm = TRUE))

# Extract means for annotations
mean_black <- mean_values$mean_y[mean_values$treatment == FALSE]
mean_blue <- mean_values$mean_y[mean_values$treatment == TRUE]

# Calculate the difference (RDD estimator)
basic_model <- rdrobust(df$y, df$x, p=1, h=.1)
rdd_estimate <- basic_model$coef[1]
vec_estimate[4] <- rdd_estimate
se_estimate[4] <- basic_model$se[2]


# Define the position for the bracket and text
bracket_height <- max(mean_black, mean_blue) + abs(mean_blue - mean_black) * 0.001  # slightly above the highest line

mid_y <- mean(mean_black, mean_blue)  # Midpoint between means for text


# Create the plot
ggplot(df_long, aes(x = x, y = y, colour = treatment)) +
  geom_point() +
  scale_colour_manual(values = c("black", "blue")) +
   geom_segment(aes(x = min(x), xend = 0, y = mean_black, yend = mean_black), colour = "black") +
  geom_segment(aes(x = 0, xend = max(x), y = mean_blue, yend = mean_blue), colour = "blue") +
  labs(x = "Running Variable", y = "Resultados observados - Y") +
  theme_minimal()  +
  geom_segment(aes(x = 0, y = mean_black, xend = 0, yend = bracket_height), colour = "black") +
  geom_segment(aes(x = 0, y = mean_blue, xend = 0, yend = bracket_height), colour = "blue") +
  annotate("text", x = 0, y = mid_y, label = paste("RDD Estimator: ", round(rdd_estimate, 2), "-.1 < x < .1"), 
           size = 5, colour = "red", vjust = -1) 

```


```{r plot-efeitos, echo=TRUE, message=FALSE, warning=FALSE}
df1 <- data.frame(
  estimate = vec_estimate,
  se       = se_estimate,
  lower    = vec_estimate - 2 * se_estimate,
  upper    = vec_estimate + 2 * se_estimate,
  h     = c("Aut" , "h=1", "h=.5" , "h=.1")  # ou names(vec_estimate) se o vetor for nomeado
)

# 2) Plote com pontos e barras de erro
ggplot(df1, aes(x = h, y = estimate)) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1) +
  labs(
    x     = "h",
    y     = "Estimativa",
    title = "Efeitos estimados com IC (±2×SE)"
  ) +
  theme_minimal()

```


## Densidade descontínua - results
```{r density-plot3, echo=FALSE, eval=TRUE}

# Generate a random sample with a density discontinuity at 0
set.seed(42)
x <- rnorm(2000, mean = -0.5)
x[x > 0] <- x[x > 0] * 2

# Estimation
rdd <- rddensity(X = x)
```



## Regressão RDD
```{r reg-rdd, echo=TRUE, eval=TRUE}
library(rdrobust)
# Assuming the cutoff is at x=0
basic_model <- rdrobust(y = df$y, x = df$x, c = 0)
summary(basic_model)
```

## Placebo Tests

Testando descontinuidade em covariáveis predeterminadas: covariáveis que não devem ser afetadas pelo tratamento não devem apresentar salto no ponto de corte.

Testando descontinuidades em outros pontos: verificar a existência de descontinuidades em pontos arbitrários ao longo da variável de ordenação.

Uso de VDs placebos: se uma variável dependente que não deveria ser afetada pelo tratamento apresentar descontinuidade significativa, isso levanta dúvidas sobre a validade do desenho RD.

Avaliação de sensibilidade às covariáveis: as estimativas de RD não devem ser altamente sensíveis à inclusão ou exclusão de covariáveis.

## PCRD

Marhsall (2024) na AJPS introduz a nomenclatura do desenho de pesquisa Politician characteristic regression discontinuity (PCRD). Basicamente, o argumento é que RDD não permite identificar efeito de características de políticos (como gênero, profissão, raça, ideologia, alinhamento com govenro federal etc.)

"In contrast, the treatment in PCRD designs — which instead seek to estimate the LATE of an elected politician characteristic — is defined by possessing (or not) predetermined characteristic X, conditional on narrowly winning an election. (...) restricting attention to close elections entails conditioning on candidate vote shares that may be affected by X. (...) [It] generally introduce bias — even when X is independent of other predetermined variables and the weak continuity assumption underpinning standard RD designs holds." (p. 495)

Basicamente, Marshall está dizendo que nesses casos, close election é um collider, e isso abre as portas para viéses de variáveis que causem $y$ e se a eleição é apertada.

```{r DAG, echo=FALSE}

library(ggdag)
dag <- dagify(
  y ~ genero + competencia,
  close_election ~ competencia + genero
)

ggdag(dag)

```

## Checlist para um paper

Teste de balancemaneto de variáveis de pré-tratamento (não impactadas pelo tratamento)

Teste de permutação no cuttoff (outra forma de olhar balanceamento)

Densidade da running variable (teste de McCrary)

Testes de placebo (cutoffs arbitrários. Estimativa não muda)

Gráfico com a descontinuidade

Estimativas baseadas em bandwith ótimos, e local linear regression

Análise de robustez junto com a escolha do bandwith (apresente graficamente)

Ordem preferida: primeiro estabelecer a validade da estratégia, depois detalhes da estimação.

## Referências

Canay, I. A., & Kamat, V. (2018). Approximate permutation tests and induced order statistics in the regression discontinuity design. The Review of Economic Studies, 85(3), 1577-1608.

Cattaneo, M. D., Idrobo, N., & Titiunik, R. (2024). A practical introduction to regression discontinuity designs: Extensions. Cambridge University Press.

Cattaneo, M. D., Idrobo, N., & Titiunik, R. (2019). A Practical Introduction to Regression Discontinuity Designs: Foundations. Elements in Quantitative and Computational Methods for the Social Sciences.

Cattaneo, M. D., & Titiunik, R. (2022). Regression discontinuity designs. Annual Review of Economics, 14(1), 821-851.

De Magalhães, L., Hangartner, D., Hirvonen, S., Meriläinen, J., Ruiz, N. A., & Tukiainen, J. (2025). When Can We Trust Regression Discontinuity Design Estimates from Close Elections? Evidence from Experimental Benchmarks. Political Analysis, 1-8.

Fitzgerald, J. (2025). Manipulation Tests in Regression Discontinuity Design: The Need for Equivalence Testing.

Gelman, A., & Imbens, G. (2019). Why high-order polynomials should not be used in regression discontinuity designs. Journal of Business & Economic Statistics, 37(3), 447-456.

Marshall, J. (2024). Can close election regression discontinuity designs identify effects of winning politician characteristics?. American Journal of Political Science, 68(2), 494-510.

Erikson, R. S., & Rader, K. (2017). Much ado about nothing: rdd and the incumbency advantage. Political Analysis, 25(2), 269-275.

De la Cuesta, B., & Imai, K. (2016). Misunderstandings about the regression discontinuity design in the study of close elections. Annual Review of Political Science, 19(1), 375-396.

Marshall, J. (2024). Can close election regression discontinuity designs identify effects of winning politician characteristics?. American Journal of Political Science, 68(2), 494-510.

- Tutorial: https://congressdata.joshuamccrain.com/regression_discontinuity.html

<!--chapter:end:07-RDD.Rmd-->

# Diferença em Diferenças

## Modelo básico 2x2

Vamos considerar primeiro um cenário de dois grupos $G \in \{1,2\}$ e dois períodos de tempo $T \in \{1,2\}$.

A notação de resultados potenciais é:
$Y_{gt}(0,0)$ é o resultado potencial da unidade $g$ no período $t$ se não for tratada nos dois períodos.
$Y_{gt}(0,1)$ é o resultado potencial da unidade $g$ no período $t$ se for tratada no segundo período.

Usualmente nós simplificamos a notação com dois períodos para $Y_{gt}(0)$ e $Y_{gt}(1)$. A vantagem da notação mais complexa é para manter a ideia de que o path (caminho) pode vir a ser relevante.

Supondo, como usual, que temos um tratamento binário $D$, e que ele é ativado (implementado) apenas no período $2$ para um dos grupos, temos a seguinte tabela para descrever como usualmente se pensa as relações causais.

```{r tabela-did, echo=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Conteúdo da tabela (linhas: D = 0 e D = 1; colunas: t = 0 e t = 1)
tbl <- matrix(
  c("$\\gamma_0 + \\alpha_i$",            "$\\gamma_1 + \\alpha_i$",
    "$\\gamma_0 + \\alpha_i + \\tau_i$",  "$\\gamma_1 + \\alpha_i + \\tau_i$"),
  nrow = 2, byrow = TRUE)

# Rótulos de linhas e colunas
rownames(tbl) <- c("$D = 0$", "$D = 1$")
colnames(tbl) <- c("$t = 0$", "$t = 1$")

# Geração da tabela
kable(tbl, escape = FALSE, booktabs = TRUE,
      align = c("r", "c", "c")) %>%          # alinhamento das colunas
  kable_styling(latex_options = "hold_position") %>%  # mantém a posição no PDF
  column_spec(1, border_right = TRUE)        # barra vertical após a 1ª coluna
```

A diferença para cada grupo $g$ é:
$$
y_{g1} - y_{g0} = (\lambda_1 - \lambda_0) + \tau_i(D_i1 - D_i0)
$$
Como pode haver mudança nos resultados apenas pela passagem do tempo, o efeito causal é não-identificado.
Contudo, veja que:

$$
\mathbb{E}[y_{g1} - y_{g0}|D_{i1} - D_{i0} = 1] - \mathbb{E}[y_{g1} - y_{g0}|D_{i1} - D_{i0} = 0] = \mathbb{E}[\tau_i(D_{i1} - D_{i0})|D_{i1} - D_{i0} = 1]
$$
Unpacking:

1. $\mathbb{E}[y_{g1} - y_{g0}|D_i1 - D_{i0} = 1]  = (\lambda_1 - \lambda_0) + \mathbb{E}[\tau_i|(D_{i1} - D_{i0})=1]$ e 

2. $\mathbb{E}[y_{g1} - y_{g0}|D_i1 - D_{i0} = 0] = (\lambda_1 - \lambda_0)$,

então a diferença é $(\lambda_1 - \lambda_0) + \tau_i -  (\lambda_1 - \lambda_0) = \mathbb{E}[\tau_i|D_{i1}=1]$.

## TWFE

É possível estimar um modelo de DiD com regressão.

$$
y_{gt} = \alpha + \beta_1 Post_t + \beta_2 Treat_g + \tau (Post_t \times Treat_g) + e_{gt}
$$
Outras parametrização é:
$$
y_{gt} = \alpha_g + \lambda_t + \tau D_{it} + e_{gt}
$$

A segunda parametrização é chamada de "two-way fixed effects", pois usamos um efeito fixo de unidade e um de tempo.

## Pressupostos

Os pressupostos de identificação de DiD são:

1. Tendências Paralelas."Na ausência de tratamento, a média dos resultados potenciais teriam evoluído em paralelo".

$\mathbb{E}[Y_{g2}(0) - Y_{g1}(0)|D_g=1] = \mathbb{E}[Y_{g2}(0) - Y_{g1}(0)|D_g=0]$

Suposição paramétrica das PT: $Y_{gt}(0) = \alpha_g + \lambda_t + e_{it}$
Isso é na verdade um resultado: é possível mostrar que supor este modelo implica PT.

2. Não-antecipação: tratamento não possui efeito no período anterior.
$\mathbb{E}[Y_{g1}(0)] = \mathbb{E}[Y_{g1}(1)]$

## Aplicação

Vamos ver um exemplo no R, a partir de um estudo meu. Os dados são de um projeto da Transparência Brasil, chamado de Obra Transparente. O projeto consistiu em uma intervenção em 20 cidades do Sudeste, em que treinamento e informações foram dados a ongs locais para monitoramento de obras de creches e escolas. O projeto começou em maio de 2017 e terminou em junho de 2019. Os dados trazem informações sobre as obras nas cidades do projeto e nas demais cidades onde havia obras similares nos mesmos estados.

```{r obra-transparente-import, warning=FALSE, message=FALSE}
library(here, quietly=TRUE)
library(knitr)
data_ot <- readRDS(here("Dados", "obra_transparente.RDS"))
head(data_ot) %>%
  kable()
```

Como o gráfico abaixo mostra, o grupo controle possui percentual mais elevado de obras concluídas em comparação ao grupo de tratamento, mesmo antes do projeto ter se iniciado. Olhando para outras covariáveis (não mostradas aqui), de fato os dois grupos eram bastante desbalanceados. Porém, apesar da diferença de nível, as mudanças (evolução temposal) são similares. Isso sugere um dif in dif como uma metodologia adequada para estimar o efeito causal.

```{r obra-transparente, warning=FALSE, message=FALSE, echo=FALSE}
library(ggplot2)
library(tidyverse)

data_ot %>%
  mutate(group_treated = ifelse(group_treated == 0, "Controle", "Tratamento")) %>%
  group_by(periodo, group_treated) %>%
  summarise(taxa_conclusao = mean(concluida)) %>%
  ggplot(aes(y=taxa_conclusao, x= periodo)) + geom_point(aes(colour = factor(group_treated))) +
  geom_vline(xintercept=4) +
  geom_line(aes(colour = factor(group_treated))) + theme_bw() + ylab("Percentual de obras concluídas") + xlab("Período") +
  scale_colour_manual(values = c("Controle" = "red", "Tratamento" = "blue"), name=NULL)
```

A partir do período 4 o tratamento já poderia fazer efeito, mas ele é muito pequeno (leve mudança na inclinação) e o efeito é relevante apenas após o período 5. Temos portando efeitos dinâmicos.Vamos inicialmente ajustar um modelo estático, considerando apenas o período 1 e 5.

```{r obra-transparente-did, warning=FALSE, message=FALSE, echo=TRUE}
library(estimatr)
library(modelsummary)
library(fixest)
data_ot_reg <- data_ot %>%
  filter(periodo %in% c(1,5)) %>%
  mutate(post = ifelse(periodo == 5, 1, 0))

did <- lm_robust(concluida ~ post + group_treated + post*group_treated, data=data_ot_reg,
                 clusters = municipio)
msummary(did, stars = c('*' = .1, '**' = .05, '***' = .01))

did_alt <- feols(concluida ~ post_treat| municipio + periodo,
                              cluster = "municipio",
                              data = data_ot_reg)
etable(did_alt) %>%
  kable()
```

## Múltiplos períodos

O que acontece se tivermos múltiplos períodos, isto é, $t>2$?

1. Múltiplos períodos antes do tratamento ser implementado

2. Múltiplos períodos após o tratamento ser implementado.
Precisamos escolher um período de comparação, $t_0$.

Nos últimos 10 anos, uma grande problematização e desenvolvimento de testes ,estimadores e entendimento do que é DiD com múltiplos períodos. Impossível cobrir tudo em uma única aula. Recomendo as vídeo-aulas do [grupo de estudo em DiD](https://www.youtube.com/playlist?list=PLVObvb_htcuBt8mV9yNagt7hK9FL5KXeE).

## Tendências Paralelas

A suposição de tendências paralelas significa que $\mathbb{E}[[Y_{i,t}(0) − Y_{g,t−1}(0)]$ não varia entre grupos $g$. Essa suposição implica que os nunca-tratados seguem um modelo de efeitos fixos duplo (Two-way fixed effects ou TWFE):

$$
\mathbb{E}[Y_{g,t}(0)] = \alpha_i + \lambda_t
$$
Uma outra forma de escrever essa suposição é:
$$
Y_{g,t}(0) = \alpha_i + \lambda_t + e_{it} \text{, com } \mathbb{E}[e_{it}] = 0
$$
Demonstrar equivalência é demonstrar que um implica o outro. Vamos começar mostrando que TWFE implica PT.

Supondo que TWFE é verdade, então $\mathbb{E}[[Y_{i,t}(0) − Y_{g,t−1}(0)] = \alpha_i + \lambda_t - (\alpha_i + \lambda_{t-1}) = \lambda_t - \lambda_{t-1})$, para todo $g$. Como a diferença no tempo $\lambda_t - \lambda_{t-1})$ não depende de $g$, então a PT é satisfeita.

Vamos agora mostrar a otra implicação. Sem perda de generalidade, defina $\lambda_1 = 0$, isto é, o efeito do período 1 é 0. Poderia ser qualquer outro valor, mas zero vai facilitar. E vamos definir $\alpha_g = \mathbb{E}[Y_{g,1}0]$, ou seja, 

Se as tendências não forem exatamente paralelas, Rambachan e Roth (2023) desenvolveram uma forma de impor restrições sobre quão diferentes as tendências podem não ser paralelas pós-tratamento em comparação com o período pré-tratamento. O pacote no R honestDiD permite implementar isso. Assim conseguimos obter identificação parcial (intervalo para as estimativas), em vez de estimação pontual. O parâmetro M controla quanto o desvio é maior em relação ao observado no pré-teste. Se M é igual a 1, temos o mesmo desvio no máximo. Se M igual a 2, duas vezes maior e assim por diante.

```{r HonestDiD, warning=FALSE}
library(HonestDiD)
library(tidyverse)
library(knitr)
library(fixest)

# Install remotes package if not installed
#install.packages("remotes")

# Turn off warning-error-conversion, because the tiniest warning stops installation
#Sys.setenv("R_REMOTES_NO_ERRORS_FROM_WARNINGS" = "true")

# install from github
#remotes::install_github("asheshrambachan/HonestDiD")


# Run model
# twfe_results <- feols(rating ~ i(goodr, qa) | year_month + asin,
#                 cluster = c("asin"),
#                 data = GoodAma)
# 
# fixest::iplot(twfe_results)
# 
# # Save coefficients
# betahat <- summary(model_4)$coefficients
# 
# # Save the covariance matrix
# sigma <- summary(model_4)$cov.scaled
# 
# ## Identificação Parcial
# 
# delta_rm_results <- createSensitivityResults_relativeMagnitudes(
#     betahat = betahat, #coefficients
#     sigma = sigma, #covariance matrix
#     numPrePeriods = 1, #num. of pre-treatment coefs
#     numPostPeriods = 1, #num. of post-treatment coefs
#     Mbarvec = seq(0.5,2,by=0.5) #values of Mbar
#   )
# 
# delta_rm_results %>%
#   kable()
```

## Múltiplos períodos pós-tratamento

Provavelmente, $\tau$ não é constante no tempo e entre unidades. Efeito do tratamento pode depender de quando começou. Pode depender da duração. Precisamos de um modelo mais sofisticado de regressão. O modelo que fizemos estima uma média dos efeitos. É preciso ter cuidado, pois se a amostra não for completa (não-balanceada), pode gerar problemas. 

A primeira extensão do modelo é considerar um did dinâmico. Como fazemos isso?

$$
Y_{g,t} = \alpha_i + \lambda_t + \sum_{t=1, t \neq t_0}^T \delta_t D_{gt} + e_{gt}
$$
Essa equação toma como referência o período $t_0$, em que o tratamento foi implementado (para todas as unidades tratadas) ao mesmo tempo.

Um dos coeficientes é não identificado por causa do $\alpha_i$, por isso precisamos excluir um período como categoria de referência.
E todos os coeficientes medem o efeito relativo ao período $t_0$ de referência.

Suposição de PT foi mais forte no modelo acima: $Y_{g,t}(d) - Y_{g,t-k}(d) = \lambda_t - \lambda_{t-k}$ para todos os $k$ e $d$. 

Podemos testar pré-tratamento.


## Análise de sensibilidade em DiD


$$
y_{gt} = \alpha_g + \lambda_t + \tau_{gt}D_{it} + e_{gt}
$$

Podemos pensar que o $\tau$ é a média dos $\tau_{gt}$. Veja que se nós pudéssemos reescrever a equação de regressão como 
$y_{gt} -\alpha_g - \lambda_t =  \tau_{gt}D_{it} + e_{gt}$, bastaria rodar um modelo de OLS tradicional e estimar essa média. Nossa vd seria $y_{gt} -\alpha_g - \lambda_t$ e o tratamento uma variável binária indicando se o tratamento ocorreu. 
Acontece que não sabemos os efeitos fixos. E se nós estimarmos eles? Utilizando o torema FWL, temos:

Primeiro, extraio os resíduos de uma regressão apenas com os efeitos fixos:
$$
y_{gt} = \alpha_g + \lambda_t + \text{resíduos}_Y
$$
Se chamar os resíduos de $\tilde{y}_{gt}$, tenho tudo de $y_{gt}$ que não é explicado pelos efeitos fixos. E posso reescrever: $y_{gt} = \alpha_g + \lambda_t + \text{resíduos}_Y$ como $\tilde{y}_{gt} = y_{gt} -\alpha_g - \lambda_t$.


Em seguida, residualizo o tratamento:
$$
D_{gt} = \alpha_g + \lambda_t + \text{resíduos}_D
$$
Novamente, vou chamar os resíduos de $\tilde{D}_{gt}$



Então, posso rodar uma regressão $\tilde{y}_{gt} = \tilde{D}_{gt} + e_{gt}$. Ou ainda:

$$
y_{gt} - \tilde{\alpha}_g - \tilde{\lambda}_t = \tau_{gt}\tilde{D}_{it} + e_{gt}
$$
Essa regressão estima $\hat{\tau} = \sum w_{gt}\tau_{gt} \neq \tau$.

Esses pesos podem até mesm oser negartivos e a estimativa $\hat{\tau}$ ter sinal oposto a $\tau$. A intuição é porque estamos comparando bananas com laranjas. Há grupos que são tratados em momentos distintos, e dependendo do tamanho dos efeitos em cada momento do tempo, a média ponderada dessas comparações dá algo estranho.

A solução proposta do Gardner de regressão DiD em dois estágios é justamente evitar esse problema rodando $y_{gt} - \tilde{\alpha}_g - \tilde{\lambda}_t = \tau_{gt}D_{it} + e_{gt}$.

Estágio 1: Estime os efeitos fixos usando observações não tratadas ou ainda não tratadas.

Estágio 2. Rode a regressão $y_{gt} - \tilde{\alpha}_g - \tilde{\lambda}_t = \tau_{gt}D_{it} + e_{gt}$.

Obviamente, o cálculo do erro padrão se torna mais complexo nesse caso, pois há ruído extra introduzido na nova VD. Felizmente, o pacote {did2s} faz tudo isso pra gente.

Se você olhar os papers mais recentes publicados nos top journals, eles estão usando esse tipo de estimador.

## DiD generalizado

Nós permitimos que cada unidade, por exemplo, tenha sua própria tendência. Ou que o resultado potencial do controle (não-tratado) dependa de covariáveis que variam no tempo, ou seja, a tendência paralela é condicional às covariáveis.
A única coisa não permitida é interação entre efeitos fixos de unidade e tempo.


```{r obra-transparente-did-din, warning=FALSE, message=FALSE, echo=TRUE}

did_din = feols(concluida ~ i(periodo, group_treated, ref=3) | id + periodo, data_ot)

etable(did_din) %>%
  kable()
```

## DID com adoção escalonada (staggered timing)

No meu exemplo, tratamento foi o mesmo para todas as unidades ao mesmo tempo. Mas é comum que não aconteça assim. 

1. Qual é o estimando quando tenho adoção escalonada no tempo? Com quem estou comparando?

Digamos que quero ver o efeito da biometria sobre comparecimento eleitoral. Como ela foi escalonada no tempo, podemos adotar um modelo de DiD. Nesse caso, uma vez implementado (turned on), não volta atrás (turn off). Porém, há casos em que a política pode ser ativada ou desativada. Exemplo: política de uso de câmeras corporais pela política. Tarcísio desativou por um tempo (STF impediu). Isso cria complicações para definir o grupo de controle adequado.

## Paper Voter Gratitude Last Long?

```{r elbe-import, warning=FALSE, message=FALSE, echo=TRUE}
library(haven)
elbe1994_98 <- read_dta(here("Dados", "Elbe", "1994_1998.dta")) 

elbe0 <- elbe1994_98 %>%
  dplyr::select(wkr, wkrname, year, spd_z_vs, Flooded)

elbe1998_02 <- read_dta(here("data",  "Elbe", "1998_2002.dta"))

elbe1 <- elbe1998_02 %>%
  dplyr::select(wkr, wkrname, year, spd_z_vs, Flooded) %>%
  dplyr::filter(year == 2002) 


elbe1998_05 <- read_dta(here("data",  "Elbe", "1998_2005.dta"))

elbe2 <- elbe1998_05 %>%
  dplyr::filter(year == 2005) %>%
  dplyr::select(wkr, wkrname, year, spd_z_vs, Flooded)

elbe <- bind_rows(elbe0, elbe1, elbe2)

```

```{r elbe-did, warning=FALSE, message=FALSE, echo=TRUE}
did_short <- feols(spd_z_vs ~ Flooded| wkr + year,
                 cluster = "wkr",
                 data = elbe1998_02)
etable(did_short)

did_din = feols(spd_z_vs ~ i(year, Flooded, ref=1998) | wkr + year, elbe)
etable(did_din)

```

```{r elbe-did-het, warning=FALSE, message=FALSE, echo=TRUE}
Sys.setenv(RGL_USE_NULL = TRUE)
library(DIDmultiplegtDYN)

elbe_het <- elbe %>%
  rename(Y = spd_z_vs,
         G = wkr,
         D = Flooded,
         T = year)

did_het <- did_multiplegt_dyn(
    df = elbe,
    outcome = "spd_z_vs",
    group = "wkr",
    time = "year",
    treatment = "Flooded",
    effects = 2,
    placebo = 2,
    cluster = "wkr"
)

summary(did_het)
did_short <- feols(spd_z_vs ~ Flooded| wkr + year,
                 cluster = "wkr",
                 data = elbe1998_02)
etable(did_short)

did_din = feols(spd_z_vs ~ i(year, Flooded, ref=1998) | wkr + year, elbe)
etable(did_din)

```
## Referências

de Chaisemartin, C., & D’Haultfœuille, X. (2023). Credible answers to hard questions: Differences-in-differences for natural experiments. Available at SSRN.

Rambachan, A., & Roth, J. (2023). A more credible approach to parallel trends. Review of Economic Studies, 90(5), 2555-2591.


<!--chapter:end:08-DiD.Rmd-->

# Time-Series Cross-Section (TSCS)

## Introdução

Dados de Painel são definidos como consistindo de observações repetidas de uma mesma unidade $i = 1, \cdot, N$ no período $t = 1, \cdot, T$. O termo dados de painel tem origem em surveys em ondas, em que o mesmo indivíduo era rastreado ao longo do tempo. Em ciência política também chamamos esse tipo de dado de **Time-Series Cross-Section**, TSCS abreviado. É basicamernte a mesma coisa. A distinção foi introduzida na literatura de ciência política portque tipicamente surveys em ondas possuem $T$ pequeno, enquanto dados de TSCE (país, estados municípios) típicos da política comparada e Relaçòes Internacionais possuem $T$ "grande", eventualmente maior do que $N$ (exemplo, países da OCDE ao longo de 50 anos, estados brasileiros ao longo de 30 anos etc.).

Uma observação de uma Vd e uma VI é dada pelo par $(y_{it}, x_{it})$, em que $i$ indexa a unidade e $t$ o tempo.

Tradicionalmente a literatura categorizava os dados de painel em balanceados (mesmo período de tempo para todas as unidades) e não-balanceado (períodos de tempo diferentes para as unidades). Essa terminologia confunde com nossa ideia de balanceamento em matching, de forma que mais recentemente tem sido substituída por dados completos (todas as unidades são observadas pelo mesmo período $T$) ou incompletos (algumas observações são ausentes para alguns períodos de algumas unidades).

Em TSCS, podemos ter países que deixam de existir (URSS, Yugoslávia) ou serem criados (Sérvia, Montenegro). Isso vale também para estados e municípios. Não é muito claro que pensar como dados ausente faz sentido, pois não é que não foram observados (como em um survey), mas a entidade nem existe mais (ou passou a existir apenas após um tempo). Isso cria potencialmente alguns tipos de problemas que a literatura metodológica basicamente tem ignorado. Em meu doutorado, eu estudei o efeito de regimes políticos sobre a adesão a tratados de patentes. Porém, não é muito claro se a adesão da URSS em um período $t^{\star}$ deve ser atribuída à Rússia em ($t > t^{\star}$). E no caso da Yuguslávia? Ou Sérvia e Montenegro, que posteriormente se dividiram? As consequências dessas decisões é uma questão tanto substantiva quanto metodológica. Mas, até onde sei, pouco ou nada investigada.

Os dados podem ser organizados no banco de dados em dois formatos: **long** e **wide**. O formato long, que é o padrão, organizada os dados com a coluna de unidade repetindo nas linhas tantas vezes quanto observações no tempo existirem. Já o formato wide apresenta cada unidade aparecendo em uma única linha.

![long vs wide format. Fonte: https://tavareshugo.github.io/r-intro-tidyverse-gapminder/09-reshaping/index.html](https://tavareshugo.github.io/r-intro-tidyverse-gapminder/fig/07-data_shapes.png)

### Within versus Between

Uma distinção importante quando se trata de dados de painel é entre variação *within subject* e *between subject*. Para entender essa discintção, contrastemos dois estudos hipotéticos. Em um estudo "within subject", cada indivíduo é exposto às múltiplas versões do tratamento (ex. trataamento e controle) e analisamos como os indivíduos mudaram entre exposições às variações do tratamento. Em um desenho "between-subject", aleatorizamos o tratamento e controle em dois grupos de indivíduos, os tratados e não-tratados e comparamos a diferença na variável resposta dos dois grupos.

Em dados de painel, a questão retorna, pois observamos as mesmas unidades repetidamente no tempo. Isso quer dizer que podemos, potencialmente, fazer comparações entre unidades ("between) e intra-unidades (within). Imagine que tenho uma variável $y_{it}$ medida para $N$ indivíduos em $T$ períodos, por exemplo, intenção de voto no candidato democrata. Posso então fazer os seguintes cálculos:

1. média individual: $\bar{x}_i = \frac{1}{T}\sum_{t=1}^T x_{it}$. Ou seja, média de intenção de votos de cada indivíduo nos $T$ períodos.

2. média temporal: $\bar{x}_t = \frac{1}{N}\sum_{i=1}^N x_{it}$. Ou seja, a média de intencão de voto de cada período de tempo.

3. Média geral: $\bar{x} = \frac{1}{NT}\sum_{i=1}^N\sum_{t=1}^T x_{it}$

Podemos então definir a variação *between*: $B = \sum_{i=1}^N n_i(\bar{x}_i - \bar{x})^2$. Se o painel é completo, a fórmula simplifica para:   $B = n\sum_{i=1}^N(\bar{x}_i - \bar{x})^2$. Veja que essa fórmula mede quanto de variação temos nos dados que se deve à variação entre unidades.

Para definir a variação within, temos:

Para um dado indivíduo $i$, a variabilidade das suas observações ao longo do tempo, em relação à sua média $\bar{x}_i$, é dado por $\sum_t (x_{it} - \bar{x}i)^2$. Se quisermos medir a soma total da variação within, podemos então definir: $W =  \sum_{i=1}^N \sum_{t=1}^{n_i}(x_{it} - \bar{x}_i)^2$.

A variação total, ou seja, a soma da variação em torno da média geral, é dada por: $\sum_{i=1}^N\sum_{i=1}^{n_i} (x_{it} - \bar{x})^2 = W + B$

## OVB

Suponha o DAG abaixo, em que $a$, uma variável invariante no tempo é não observada:

```{r dag-fe}
library(ggdag)
dag <- dagify(
  y ~ x + a,
  x ~ a,
  latent = "a"
)

ggdag(dag)
```

Ela leva ao clássico problema de variável omitida. Dados de painel nos permite remover essa variável de confusão. Há várias formas de mostrar isso, e vou optar pela abordagem de centrar as variáveis. Suponha uma forma paramétrica do modelo estrutural dado por: $y_{it} = \alpha + \beta_0 x_{it} + a_i + e_{it}$. Suponha, para simplificar, que o painel é completo.

Agora, considerem os seguintes passos:

\begin{aligned}
\bar{y}_i &= \frac{1}{T}\sum_{t=1}^T y_{it} \\
         &= \frac{1}{T}\sum_{t=1}^T (\alpha + \beta_0 x_{it} + a_i + e_{it}) \\
         &= \frac{1}{T}\sum_{t=1}^T \alpha + \frac{1}{T}\sum_{t=1}^T\beta_0 x_{it} + \frac{1}{T}\sum_{t=1}^T a_i + \frac{1}{T}\sum_{t=1}^Te_{it}) \\
         &= \alpha + \frac{\beta_0}{T}\sum_{t=1}^T x_{it} + a_i + \frac{1}{T}\sum_{t=1}^Te_{it} \\
         &= \alpha + \beta_0 \bar{x}_i + a_i + \bar{e}_i 
\end{aligned}

Agora, definindo $\tilde{y}_{it} = y_{it} - \bar{y}_i$, temos:

\begin{aligned}
\tilde{y}_{it}i &= y_it - \bar{y}_i \\
         &= \alpha + \beta_0 x_{it} + a_i + e_{it} - (\alpha + \beta_0 \bar{x}_i + a_i + \bar{e}_i) \\
         &= (\alpha - \alpha) + (\beta_0 x_{it} - \beta_0 \bar{x}_i) + (a_i - a_i) + (e_{it}  - \bar{e}_i)  \\
         &= \beta_0(x_{it} - \bar{x}_i) + (e_{it}  - \bar{e}_i) \\
         &= \beta_0 \tilde{x} + \tilde{e}_{it} \text{, em que } \tilde{x} = x_{it} - \bar{x}_i \text{ e } \tilde{e}_{it} = e_{it}  - \bar{e}_i
\end{aligned}

Temos então um modelo de regressão em que os $\a_i$ foram removidos da equação estrutural e, portanto, não podem mais causal viés de variável omitida.

A pergunta para vocês agora é: qual o estimando que tal estimador estima?

Pensem antes de responder...

Vamos formular a questão um pouco em termos de resultados potenciais.

## Estimandos

Há muitos estimandos possíveis com dados TSCS. Eis alguns possíveis estimandos de interesse (baseado em Blackwell e Glynn, 2018). Antes ,vamos definir: todos os tratamentos para uma dada unidade formam a história do tratamento $X_i = \{x_{i1}, x_{i2}, \cdots, x_{iT}\}$. A história parcial dos tratamentos até $t$ é $X_{i, 1:t} = \{x_{i1}, x_{i2}, \cdots, x_{it}\}$. Variáveis de controle $W$ podem ser definidas de maneira similar.

1. O efeito de uma história de tratamento. Posso estar interessado em entender o efeito de uma particular história em contraposição a outra. Digamos, um país que sempre foi democracia versus um que sempre foi ditadura. Em termos de resultados potenciais: $Y_{it}(X_{i, 1:t}) - Y_{it}(X^{\prime}_{i, 1:t})$, em que $\prime$ indica uma história alternativa. No caso, $Y_{it}(1, 1, \cdots, 1)$ versus $Y_{it}(0, 0, \cdots, 0)$. Como sempre, nosso estimando típico é uma média, isto é: $\tau_{X_{i, 1:t}, X^{\prime}_{i, 1:t}} = \mathbb{E}[Y_{it}(X_{i, 1:t}) - Y_{it}(X^{\prime}_{i, 1:t})]$.

Obviamente, existem muitas combinações de histórias possíveis (de fato, $2^t$ se o tratamento é binário). Como vamos observar muitas histórias distintas, teremos em geral poucas ou nenhuma observação de uma dada história para estimar o efeito causal com precisão.

2. Efeito de história parcial (recente) do tratamento. Vamos definir resultado potencial dos últimos $j$ períodos $Y_{it}(X_{t-j:t}) = Y_{it}(X_{i,1: t-j-1}, X_{t-j:t})$. Nós interpretamos essa quantidade como o efeito causal de observar a história até o período $t-j-1$ e então fixar o valor do tratamento na história $X_{t-j,:t}$. 

3. Efeito Contemporâneo do Tratamento (Contemporaneous Treatment Effect, CET): $\tau_c(t) = \mathbb{E}[Y_{it}(X_{i,1: t-j-1}, X_{t-j:1}) - Y_{it}(X_{i,1: t-j-1}, X_{t-j:0})]$. Ou seja, deixamos as unidades terem qualqquer história, e investigamos o efeito do tratamento no último período. Veja que estamos calculando a média sobre todas as histórias até o período $t$. 

## Resultados Potenciais

Vamos considerar, inicialmente, um caso de depois períodos e em que indíviduos são tratados nos dois períodos ou não tratados nos dois períodos. Isso significa que de quatro resultados potenciais possívels $Y_i(0,0), Y_i(0,1), Y(1,0)_i, Y_i(1,1)$ só observamos $Y_i(0,0), Y_i(1,1)$.

Digamos que estamos interessados em $\mathbb{E}[Y_i(1,1) - Y_i(0,0)]$. Se a sequência de tratamento for atribuída aleatoriamente, isto é, sorteamos que irá receber $x_i = (1,1)$ e $x_i = (0,0)$, então podemos utilizar os resultados observados para recuperar nosso estimando: $\mathbb{E}[Y_i|x_{i1} = 1, x_{i2}=1] - \mathbb{E}[Y_i|x_{i1} = 0, x_{i2}=0]$. Veja que nós aleatorizamos a sequência dos tratamentos. Tal tipo de aleatorização implica que exogeneidade estrita é statisfeita, que formalizamos a seguir com resultados potenciais:

$$
Y_{it}(1), Y_{it}(0) \perp x_{it}|\mathbf{W}^{1:T}_i, a_i, \mathbf{f}^{1:T}\text{, para todo } i, t, s, 
$$

As variáveis em negrito indicam que são (potencialmente) um vetor de variáveis. A suposição de exogeneidade estrita implica a suposição de tendências paralelas.

Em palavras, essa suposição (que é um restrição de exclusão) quer dizer que: 

1. não há time-varying confoundings;

2. Resposta passada não causa diretamente resposta presente, isto é, sem flecha de $y_{t-1}$ para $y_t$;

3. Semfeedback de variáveis causadas por tratamentos passados (resultados passados ou outras covariáveis) e o status de tratamento corrente e futuro. Ou seja, sem flechas de $y_{t-1}$ para $x_t$ ou de $w_{t-1}$ para $x_t$.

4. Sem “carryover effects” do tratamento presente para resultados futuros, ou seja, sem flecha de $x_{t-1}$ para $y_t$ ou $y_{t+1}$.

Qualquer violação de uma ou mais condições acima implica que a suposição de exogeneidade restrita não foi satisfeita.


O DAG abaixo apresena exogeneidade estrita para um caso simplificado de três períodos:

```{r echo=FALSE}
knitr::include_graphics("/Users/manoelgaldino/Documents/DCP/Cursos/Causalidade/Causalidade/imagens/DAG estrita exogeneidade.png")
```

Obviamente, essa restrição de exclusão é difícil de ser satisfeita na prática. 

Se supusermos $\mathbb{E}[e_t|x_{t1}, x_{t2}, \cdots, x_{tk}]=0$, temos o que chamamos de **exogeneidade contemporânea**, ou seja, as variáveis independentes e o termo de erro são não-correlacionadas no tempo $t$. Isso, porém, não garante que o estimador de OLS é não-viesado. Para obtermos um estimador não-viesado, precisamos supor **exogeneidade estrita**: É possível mostrar, porém, que o estimador de OLS é consistente com exogeneidade contemporânea.

Vale destacar que exogeneidade estrita exclui a possibilidade de que o termo de erro no presente possa causar mudanças futuras em $x$. Ou seja, não pode haver feedback do $y$ para futuros valores de $x$. Em outras palavras, tratamentos estritamente exógenos não podem reagir pelo que aconteceu com o $y$ no passado.

Considere o que a literatura chama de Distributed Lag Model (DLM), que basicamente consiste em introduzir valores defasados (além do presente) do tratamento. O modelo simples, fica:

$$
y_{it} = \alpha + \beta_1x_{it} + \beta_2 x_{it-1} + \cdots + \beta_2 x_{it-k} + e_{it}
$$
Um modelo relacionado, chamado de ADL (autoregressive distributed lag) incluida VD defasada:
Se for um AR(1), temos:

$$
y_{it} = \alpha + \alpha_1y_{it-1} + \beta_1x_{it} + \beta_2 x_{it-1} + e_{it}
$$
Vale a pena escrever a equação de resultado potenciais implicada por esse modelo:

$$
Y_{it}(x_{1:t}) = \alpha + \alpha_1 y_{it-1}(x_{1:t-1}) + \beta_1x_{it} + \beta_2 x_{it-1} + e_{it}
$$
Nessa formulação fica claro porque é difícil interpretar o efeito causal do tratamento em $t-1$, pois ele te mum efeito direto, via $\beta_2$ e um efeito indireto, via $y_{it-1}$.

## Modelo AR(1)

Considere o modelo AR(1):
$$
y_{t} = \beta_0 + \beta_1 y_{t-1} + e_t
$$

Suponha ademais que $\mathbb{E}[e_t|y_{t-1}, y_{t-2}, ...] = 0$. Esse pressuposto implica que $\mathbb{E}y_{t}|y_{t-1}, y_{t-2}, ...] = \mathbb{E}[\beta_0 + \beta_1 y_{t-1} + e_t|y_{t-1}, y_{t-2}, ...] = \beta_0 + \beta_1\mathbb{E}y_{t-1}|y_{t-1}, y_{t-2}, ...] + 0 = \beta_0 + \beta_1 y_{t-1}$.

Portanto, $e_t$ e $y_{t}$ são correlacionados. O modelo AR(1), isto é, com VD defasa, viola exogeneidade estrita. 

## Sequential ignorability

Uma suposição alternativa e menos demandante é a de ignorability sequencial (sequential ignorability).

O experimento equivalente a essa suposição seria quando, em cada período, o tratamento $x_{it}$ é aleatorizado condicional aos valores passados do tratamento e covariáveis variantes no tempo (incluindo valores passados da variável resposta, $y$).

O DAG abaixo ilustra a suposição de ignorability sequencial.

```{r echo=FALSE}
knitr::include_graphics("/Users/manoelgaldino/Documents/DCP/Cursos/Causalidade/Causalidade/imagens/sequential ignorability.png")
```

## Resumo



```{r echo=FALSE}
knitr::include_graphics("/Users/manoelgaldino/Documents/DCP/Cursos/Causalidade/Causalidade/imagens/identification regimes.png")
```




A princípio, e de maneira mais geral, se a história importa (isto é, os estados passados, bem como sua ordem importam), o que Scott Page (200) chamou de path dependence, então precisamos escrever os resultados potenciais de um indivíduo $i$ em $t = 1, \cdots, T$, para um tratamento binário $x_{it} \in \{0,1\}$ da seguinte forma: 
$$
y(x_{i1}, x_{i2}, \cdots, x_{it}, \cdots x_{iT})
$$
Em que o valor de $x_{it} \in \{0,1\}$ determina se, naquele período, o indivíduo foi tratado ou não. Se a história importa, no sentido de path dependence, então cada sequência é substantivamente diferente. Uma outra possibilidade é que importe quantos tratamentos e controles a unidade recebeu, mas não a ordem. Nesse caso:

$$
y(x_{i1}, x_{i2}, \cdots, x_{it}, \cdots x_{iT}) = y(\sum_{t=1}^T x_{it})
$$

Para uma dada unidade $i$ no tempo $t$, e supondo um tratamento binário $x_{it}$, o resultado potencial é: $Y(1)_{it}$ para o tratamento, e $Y(1)_{it}$ para o controle. Uma suposição implícita na nossa derivação é que se eu denotar a sequência (ou caminho) de tratamento e controle no tempo por algo como $Y(1,0,..., 1)_{it^{\star}}$ para uma resposta em $t^{\star} > 1$, a história dos resultados potenciais é irrelevante, de modo que posso simpliesmente escrever  $Y(1)_{it^{\star}}$ e similarmente para o controle. Então, sabemos que $Y(1)_{it^{\star}} = \alpha + \beta_0 x_{it^{\star}} + a_i + e_{it^{\star}}$ e $Y(0)_{it^{\star}} = \alpha + a_i + e_{it^{\star}}$.

O efeito do tratamento entre indivíduos no período t^{\star} é dado justamente por $Y(1)_{it^{\star}} - Y(0)_{it^{\star}} = \alpha + \beta_0 x_{it^{\star}} + a_i + e_{it^{\star}} - (\alpha + a_i + e_{it^{\star}}) = beta_0 x_{it^{\star}$. Como só posso observar um dos resultados potenciais para cada indivíduo no período t^{\star}, parece natual pensar que inha regressão de efeitos.

 
### Remark

Sob a suposição de **exogeneidade contemporânea**, o estimador de OLS é consistente, isto é, converge para o verdadeiro valor do parâmetro quando a amostra vai para infinito. Supondo que a série é estacionária e fracamente dependente. Formalmente, a dependência fraca implica que  $|\beta_1| < 1$.


## Suposições para Inferência

Para fazer inferência (calcular o erro padrão e fazer testes de hipótese, por exemplo), precisamos supor, além da exogeneidade estrita, a suposição de não-correlação serial. Ou seja, Conditional on X, the errors in two different time periods are uncorrelated: Corr ut,us X 5 0, for all t 2 s.

### Remark

Problemas de correlação serial impactam o cálculo do erro padrão, mas não o viés. 


## Efeitos aleatórios

Um modelo simples de efeito aleatório é dado por:

$y_{it} = \beta_{0t} + \beta_1 x_{it} + e_{it}$, micro model

$\beta_{0t} = \beta_0 + \beta_2 z_t + \mu_t$, macro model

Modelo completo:

$$
y_{it} = \beta_0 + \beta_2 z_t + \beta_1 x_{it} + (e_{it} + \mu_t)
$$

A parte "fixa" é $beta_0 + \beta_2 z_t + \beta_1 x_{it}$ e a parte "aleatória" é $e_{it} + \mu_t$. Tipicamente, assumimos que $\mu_t \sim N(0, \sigma^2_{\mu})$ e $e_{it} \sim N(0, \sigma^2_e)$.

Isso é também chamado de partial pooling (shrinkage), pois os "varying-intercept" possuem uma distribuição comum, com variância estimada pelos dados. Vejam que, se $\sigma^2_{\mu} = 0$, então os interceptos são todos iguais, e temos uma "pooled regression". Se $\sigma^2_{\mu} \to \in \infty$, então cada intercepto poderia ser estimado separadamente para cada $t$: "unpooled regression".

A suposição de identificação é:

$$
\mathbb{E}[e_{it}|x_{it}, z_t] = 0
$$

e 

$$
\mathbb{E}[\mu_{t}|x_{it}, z_t] = 0
$$

As implicações dos dois pressupostos é que $Cov(e_{it},x_{it}) = 0$ e $Cov(\mu_{t},x_{it}) = 0$. Vamos comparar com o modelo de feitos fixos, mas usando outra formulação. O modelo padrão com varráveis binárias pode ser escrito como:

$$
y_{it} = \sum_{t=1}^T \beta_{0t} D_t +  \beta_1 x_{it} + e_{it}
$$

Nós podemos estimar esse modelo diretamente, e nesse caso teremos uma estimativa para os efeitos fixos $\beta_{0t}$. Porém, tipicamente eles não são de interesse, e portanto, uma outra parametrização equivalente mostra a suposta vantagem dos efeitos fixos. Vamos centrar todas as variáveis do modelo. Primeiro, vamos definir: 

$\bar{y}_t = \sum_{i=1}^N y_{it}$

$\bar{x}_t = \sum_{i=1}^N x_{it}$

$\bar{e}_t = \sum_{i=1}^N e_{it}$

$\bar{e}_t = \sum_{i=1}^N z_{it}$

Defina a equação de regressão centrada na média como:

$$
\bar{y}_t = \frac{1}{N} \sum_{i=1}^N y_{it} = \frac{1}{N} \sum_{i=1}^N (\beta_0 + \beta_2 z_{it} + \beta_1 x_{it} + \mu_t + e_it)= \beta_0 + \beta_2\bar{z_{t}} + \beta_1\bar{x}_t + \mu_t + \bar{e}_t
$$

Subtraindo esta equação da original, temos:

$$
y_{it} - \bar{y_{t}} =  \beta_2 (z_t - \bar{z_{t}}) + \beta_1 (x_{it} - \bar{x_{t}}) + (e_{it} - \bar{e}_t)
$$

E eliminamos o intercepto e os efeitos fixos da equação, de modo que não precisamos mais de nenhum pressuposto sobre os efeitos fixos e os termos de erro.

O custo que nós pagamos é remover a variação entre unidades, ou seja, estamos estimando um modelo apenas com base na variação "within", isto é, intra-unidades no tempo.

Obviamente, não há nada especial em termos utilizado efeitos fixos de tempo. Poderíamos igualmente usar um efeito fixo de unidade, centrar e subtrair do modelo original, e obter estimativas apenas com variação entre unidades, mas não intra-unidades.

O problema de OVB com efeitos aleatórios pode ser explicado da seguinte maneira (seguindo Bell e Jones, 2015). A variação no tratamento pode ser decomposta em: $x_{it} = x_t^B + x_{it}^W$

No modelo de efeitos aleatórios $y_{it} = \beta_0 + \beta_2 z_t + \beta_1 x_{it} + (e_{it} + \mu_t)$, implicitamente assumimos que o efeito between e within sao iguais. Quando são diferentes, $\beta_1$ é uma média ponderada dos dois processos, e isso produz justamente o OVB, porque o efeito between é omitido. Bell e Jones chamam de "heterogeneity bias", para distinguir do clásico OVB.

A solução proposta por Bell e Jones, ecoando Mundlak, é adicionar um termo que caputre o efeito between: a média temporal. A equaçao fica então:

$y_{it} = \beta_0 + \beta_2 z_t + \beta_1 x_{it} + \beta_3 \bar{x}_t +  (e_{it} + \mu_t)$. Essa equação pode ser reformulada para:

$$
y_{it} = \beta_0 + \beta_2 z_t + \beta_1 (x_{it} - \bar{x}_t) + \beta_4 \bar{x}_t  +  (e_{it} + \mu_t)
$$
$\beta_1$ é o efeito within, e $\beta_4$ é o efeito between.



## Referências

Bell, A., & Jones, K. (2015). Explaining fixed effects: Random effects modeling of time-series cross-sectional and panel data. Political Science Research and Methods, 3(1), 133-153.

Blackwell, M., & Glynn, A. N. (2018). How to make causal inferences with time-series cross-sectional data under selection on observables. American Political Science Review, 112(4), 1067-1082.

Page, S. E. (2006). Path dependence. Quarterly Journal of Political Science, 1(1), 87-115.

<!--chapter:end:09-TSCS.Rmd-->

# Synthetic Control

Vamos começar com um exemplo, já famoso na literatura, de Controle Sintético. O estado da Califórnia implmentou uma proibição de uso de cigarro e digamso que queremos ver o efeito dessa proibição, isto é, nosso estimando é $\tau_{\text{ban}, \text{CA}} = Y(1)_{\text{ban}, CA} - Y(0)_{\text{ban}, \text{CA}}$.

Como não observamos $Y(0)_{\text{ban}, \text{CA}}$, temos de criar uma "Califórnia sintética". Antigamente, iremos usar alguma média dos demais estados "não-tratados"para estimar o contrafactual. Contudo, não é muito convincente.



```{r cigarro, echo=FALSE, message=FALSE, warning=FALSE}
# install.packages('scpi')
library(data.table)
library(knitr)
library(ggplot2)
library(tidyverse)
library(tidyr)
library(janitor)

cigar <- fread("https://raw.githubusercontent.com/matheusfacure/python-causality-handbook/master/causal-inference-for-the-brave-and-true/data/smoking.csv")
cigar1 <- cigar %>%
  dplyr::select(-c("lnincome","beer", "age15to24"))
cigar1 %>%
  head() %>%
  kable()


  
plot_data <- cigar1 %>%
  group_by(year, california) %>%
  summarise(sale_mean = mean(cigsale), .groups = "drop") %>%   # evita aviso
  mutate(california = factor(
    california,
    levels = c(FALSE, TRUE),
    labels = c("Demais estados", "Califórnia")
  ))

# -------------------------------------------------------------------
# 3. Plotar

ggplot(plot_data,
       aes(x = year, y = sale_mean,
           colour = california,
           linetype = california)) +
  geom_line(linewidth = 1) +
  ## linha vertical de referência
  geom_vline(
    aes(xintercept = 1988,
        colour = "Proposition 99",
        linetype = "Proposition 99"),
    linewidth = 0.8,
    show.legend = TRUE
  ) +
  ## escalas com as três categorias
  scale_colour_manual(
    values = c(
      "Demais estados" = "#2166ac",
      "Califórnia"     = "#b2182b",
      "Proposition 99" = "black"
    )
  ) +
  scale_linetype_manual(
    values = c(
      "Demais estados" = "dashed",
      "Califórnia"     = "solid",
      "Proposition 99" = "dotted"
    )
  ) +
  scale_x_continuous(
    breaks = seq(min(plot_data$year), max(plot_data$year), by = 5)
  ) +
  labs(
    title    = "Diferença nas vendas per capita de cigarros",
    x        = "Ano",
    y        = "Vendas per capita",
    colour   = "",
    linetype = ""
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position.inside = c(0.80, 0.88),
    legend.background      = element_rect(fill = "white", colour = "grey80")
  )
```


Suponha que obtivemos dados para $J+1$ unidades para unidades $j = 1, 2, ..., J+1$, e sem perda de generalidade, a primeira unidade $j=1$ é a de tratamento ou sob intervenção. O grupo de unidades para comparação (*donor pool*) é dado por $j = 2, ..., J+1$, uma coleção de unidade não-tratadas. Os dados são observados por $T$ períodos $1, 2, ..., t_0, t_1, t_2, ..., T$, em que de $1$ até $t_0$ nenhuma unidade foi tratada ou sofreu intervenção. Para cada unidade $j$, observamos também um conjunto de $k$ preditores, $X_{1j}, X_{2j}, ..., X_{kj}$, que pode incluir vaores pré-intervenção da variável resposta $y_{jt}$.

A ideia é usar com combinação linear do *donor pool*, com pesos apropriados, para estimar o contrafactual, isto é, o resultado potencial dos tratados. Lembrando que o estimando usual de interesse é o ATT:
$$
\mathbb{E}[Y(1)_{it}|D_{it}=1] - \mathbb{E}[Y(0)_{it}|D_{it}=1] 
$$
A dificuldade, como sempre, é que não observamos $\mathbb{E}[Y(0)_{it}|D_{it}=1$. Estimar ou imputar esse *missing data* a partir de uma média ponderada é o objetivo de nosso estimador. A ideia é um pouco parecida com matching, em que nós pareávamos unidades de controle com as taratdas, minimizando a distância a partir das covariáveis. Aqui, vamos fazer algo parecido, mas com uma diferença chave: vamos incluir nas covariáveis a variável resposta defasada. Esse método foi introduzido por Abadie et. al em um journal de ciência política.

Vamos usar a abordagem de Doudchenko e Imbens (2018) para apresentar o médo, pois vai faciliar a introdução posterior de diferença em diferenças sintéticas.

Nossos dados podem ser organizados da seguinte forma:

### Tratamento

Suponha, como no caso da proposição 99, que temos uma unidade tratada e o tratamento é absorvente. O banco de dado para o tratamento pode ser representado como:

\begin{aligned}
D \;=\;
\begin{bmatrix}
0 & 0 & 0 & \cdots 0 & 0\\
0 & 0 & 0 & \cdots 0 & 0\\
\vdots \\
0 & 0 & 0 & \cdots 0 & 1\\
0 & 0 & 0 & \cdots 0 & 1\\
\end{bmatrix}
\end{aligned}

Aqui, o estados estão nas colunas, Calinfórnia é a última coluna, e nas linhas temos os períodos de tempo. E podemos simplificar a matriz acima para apenas quatro blocos:

\begin{aligned}
D \;=\;
\begin{pmatrix}
\mathbf{0} & \mathbf{0}  \\
\mathbf{0} & \mathbf{1}
\end{pmatrix}
\end{aligned}

O que nos leva à seuinge matriz de resultados:

\begin{aligned}
Y \;=\;
\begin{pmatrix}
\mathbf{Y_{co, pre}} & \mathbf{Y_{tr, pre}}  \\
\mathbf{Y_{co, post}}  & \mathbf{Y_{tr, post}}
\end{pmatrix}
\;=\;
\begin{pmatrix}
Y_{co, pre}(0) & Y_{tr, pre}(0)  \\
Y_{co, post}(0)  & Y_{tr, post}(1) 
\end{pmatrix}
\end{aligned}

E de maneira similar para as covariáveis, mas vamos simplificar e supor que não temos nenhuma, sem perda de generalidade.

Relembrando, nosso estimando é dado por:
$$
\mathbb{E}[Y(1)_{it}|D_{it}=1] - \mathbb{E}[Y(0)_{it}|D_{it}=1] 
$$

E preciso para isso estimar $\mathbb{E}[Y(0)_{it}|D_{it}=1]$, em nossa nova notação: $Y(0)_{it}|D_{it}=1 \text{, p/ todo t} > t_0 =  Y_{tr, post}(0)$. E nosso estimador será:
$$
Y_{tr, post}(0) = \mu + \sum_{i \in co}w_iY_{i,t}
$$
Em que $w_i$ são os pesos do *donor pool*.

Em ADH (2010), as restrições são:

1. $\mu = 0$

2. $\sum_i w_i = 1$

3. $w_i \geq 0 \text{, } \forall i$

Restrição 1 signifca que não há diferença de nível. Suposição 2 significa que o contrafactual tem de ser contruído no suporte do *donor pool*. Suposição 3 

A intuição para o cálculo do peso é parecida da regressão linear, em que estamos minimizando a soma da distância. A diferença é que é uma soma diferente. 

$$
||\mathbf{X}_{tr} - \mathbf{X}_{co}\mathbf{W}||
$$
Lembrando que vamos incluir a VD defasada em $X$. 

Vamos para o R para ver isso em ação.
Dica: Há vários pacotes, mas o original, synth, é muito complexdo de usar e não recomendamos. 
augsynth/tidysynth and synthdid packages (original  package is tough to use)


## Implementação no R

```{r cigarro_tidysynth, echo=TRUE, message=FALSE, warning=FALSE, cache=FALSE}
# tidysynth
library(tidysynth)
library(tidyverse)
data(smoking)

smoking %>%
  head() %>%
  kable()

smoking_out <-
  smoking %>%
  # initial the synthetic control object
  synthetic_control(outcome = cigsale, # outcome
                    unit = state, # unit index in the panel data
                    time = year, # time index in the panel data
                    i_unit = "California", # unit where the intervention occurred
                    i_time = 1988, # time period when the intervention occurred
                    generate_placebos=T # generate placebo synthetic controls (for inference)
                    ) %>%
  
  # Generate the aggregate predictors used to fit the weights
  
  # average log income, retail price of cigarettes, and proportion of the
  # population between 15 and 24 years of age from 1980 - 1988
  generate_predictor(time_window = 1980:1988,
                     ln_income = mean(lnincome, na.rm = T),
                     ret_price = mean(retprice, na.rm = T),
                     youth = mean(age15to24, na.rm = T)) %>%
  
  # average beer consumption in the donor pool from 1984 - 1988
  generate_predictor(time_window = 1984:1988,
                     beer_sales = mean(beer, na.rm = T)) %>%
  
  # Lagged cigarette sales 
  generate_predictor(time_window = 1975,
                     cigsale_1975 = cigsale) %>%
  generate_predictor(time_window = 1980,
                     cigsale_1980 = cigsale) %>%
  generate_predictor(time_window = 1988,
                     cigsale_1988 = cigsale) %>%
  
  
  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window = 1970:1988, # time to use in the optimization task
                   margin_ipop = .02,sigf_ipop = 7,bound_ipop = 6 # optimizer options
  ) %>%
  
  # Generate the synthetic control
  generate_control()

# série do observado e controle sintético
smoking_out %>% plot_trends(time_window = 1970:2000)


```

A quantidade causal de interesse pode ser visualizada do seguinte modo:


```{r cigarro_tidysynth1, echo=TRUE, message=FALSE, warning=FALSE}
smoking_out %>% plot_differences()
```

E é possível visulizar os pesos de cada unidade e das variáveis:

```{r cigarro_tidysynth2, echo=TRUE, message=FALSE, warning=FALSE}
smoking_out %>% plot_weights()
```

Podemos também olhar o balanceamento entre o observado e o sintético:

```{r cigarro_tidysynth4, echo=TRUE, message=FALSE, warning=FALSE}
smoking_out %>% grab_balance_table()

```

A Inferência é complicada. O método tradicional é o chamado teste placebo, cuja intuição é a de um teste de permutação, ou seja, a gente diz que um outro estado foi tratado (NY, por exemplo), e roda o modelo de novo e assim por diante para todas as unidades do *donor pool*. O gráfico abaixo traz isso pronto.

```{r cigarro_tidysynth3, echo=TRUE, message=FALSE, warning=FALSE}

smoking_out %>% plot_placebos()

```


## Synthethic DiD

Synth DiD comebinar controle sintético com DiD, em algo novo. Então, vamos começar revisitando DiD.
Nós vimos que o estimador de DiD é equivalente a uma regressão linear com efeitos fixos de unidade e tempo. Vamos aplicar nosso estimador para os dados da da proposição 99.

```{r did, echo=TRUE, message=FALSE, warning=FALSE}
library(fixest)

smoking_did <- smoking %>%
  mutate(treatment = ifelse(state == "California" & year > 1988, 1, 0))
did <- feols(cigsale ~ treatment | state + year, data = smoking_did)

etable(did)
```

O problema dessa. estimativa é que a suposição de tendências paralelas na média não é muito crível.

```{r did1, echo=TRUE, message=FALSE, warning=FALSE}
df <- smoking_did %>%
  mutate(event_time = year - 1988,
         id = as.integer(as.factor(state))) %>%
  group_by(state) %>%
  mutate(g = ifelse(state == "California" & year >= 1988, 1988, 0))

# Estimação do modelo event study
# model_feols <- feols(
#   cigsale ~ i(event_time, ref = -1) | unidade + periodo,
#   data = df)

library(did2s)

out_es <- event_study(
  data = df,
  idname = "id",
  tname = "year",
  gname = "g",  # coluna que indica o período de tratamento para cada i
  yname = "cigsale",
  estimator = "all"
)

plot_event_study(out_es)


```

E se a gente combinasse controle sintético com DiD, isto é, usasse peso para criar tendências paralelas, e então aplicasse DiD? 

Arkhangelsky et al (2021) mostraram que podemos reescrever o estimador de controle sintético como:

$$
(\hat{\mu}, \hat{\gamma}, \hat{\tau}) = \text{arg}\,\max\limits_{\mu, \gamma, \tau}\ \sum_i \sum_t (y_{it}) - \mu - \gamma_t -D_{it}\tau)^2\hat{w}_i
$$
Já o DiD é dado por:
$$
(\hat{\mu}, \hat{\alpha}, \hat{\gamma}, \hat{\tau}) = \text{arg}\,\max\limits_{\mu, \gamma, \tau}\ \sum_i \sum_t (y_{it}) - \mu - \alpha_i - \gamma_t -D_{it}\tau)^2
$$

A a proposta dos autores, o Synthetic DiD é dada pelo estimador:
$$
(\hat{\mu}, \hat{\alpha}, \hat{\gamma}, \hat{\tau}) = \text{arg}\,\max\limits_{\mu, \gamma, \tau}\ \sum_i \sum_t (y_{it}) - \mu - \alpha_i - \gamma_t -D_{it}\tau)^2\hat{w}_i\hat{\lambda}_t
$$
Como antes, $\hat{w}_$ são pesos para cada unidade que procuram balancear a tendência pré-exposição ao tratamento nos grupos controle e de tratamento (no exemplo, demais estados e Califórnia). E introduzem pesos $\hat{\lambda}_t$ para  os períodos de tempo $t$ que procuram balancear os períodos pré-exposição com os períodos pós-exposição.

Contrast o SDiD com o DiD, e a didferença são os dois pesos. Basicamente, estamos estimando regressão linear local ao colocar mais peso em unidades que são, em média, mais similares aos tratados no período pré-exposição e enfatiza períodos mais similares ao algo (período tratado). Em outras palavras, "Time weights are designed so that the average post-treatment outcome for each of the control units differs by a constant from the weighted average of the pre-treatment outcomes for the same control units"(p. 4)

Esse estimador relaxa a suposição de tendências paralelas. Agora, precisamos que um fator latente seja paralelo.

```{r sdid, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# devtools::install_github("synth-inference/synthdid")
library(synthdid)

estimators = list(did=did_estimate,
                  sc=sc_estimate,
                  sdid=synthdid_estimate)
str(synthdid_estimate)

# converte para matriz
df_sdid <- df %>%
  dplyr::select(state, year, cigsale, treatment) %>%
  mutate(treatment = as.integer(treatment),
         year = as.integer(year),
         state = as.factor(state)) %>%
  as.data.frame() # aparentemente panel.matrices não funciona com tibble

setup <- panel.matrices(df_sdid)
head(setup) %>%
  kable()

estimates <- lapply(estimators, function(estimator) { estimator(setup$Y,
                                                               setup$N0, setup$T0) } )

head(estimates)

standard.errors = mapply(function(estimate, name) {
  set.seed(12345)
  if(name == 'mc') { mc_placebo_se(setup$Y, setup$N0, setup$T0) }
  else {             sqrt(vcov(estimate, method='placebo'))     }
}, estimates, names(estimators))

head(standard.errors)
```

Plot comparando as estimativas.

```{r sdid1, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
synthdid_plot(estimates[1:3], facet.vertical=FALSE,
              control.name='control', treated.name='california',
              lambda.comparable=TRUE, se.method = 'none',
              trajectory.linetype = 1, line.width=.75, effect.curvature=-.4,
              trajectory.alpha=.7, effect.alpha=.7,
              diagram.alpha=1, onset.alpha=.7) +
  theme(legend.position=c(.26,.07), legend.direction='horizontal',
        legend.key=element_blank(), legend.background=element_blank(),
        strip.background=element_blank(), strip.text.x = element_blank())
```

Plot comparando os pesos.

```{r sdid2, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
synthdid_units_plot(rev(estimates[1:3]), se.method='none') 
```



## Referências


Alcocer, J. J. (2025). Minority Legislators Sponsor and Cosponsor Differently from White Legislators: Causal Evidence from U.S. Congress. The Journal of Race, Ethnicity, and Politics, 1–13. doi:10.1017/rep.2025.29

Arkhangelsky, D., Athey, S., Hirshberg, D. A., Imbens, G. W., & Wager, S. (2021). Synthetic difference-in-differences. American Economic Review, 111(12), 4088-4118.

Arkhangelsky, D., & Imbens, G. (2024). Causal models for longitudinal and panel data: A survey. The Econometrics Journal, 27(3), C1-C61.

<!--chapter:end:11-Synth.Rmd-->

# LLMs e outras



## Google Colab

Para a aula de hoje, vamos usar o Google Colab, que é uma ferramenta online, gratuita, para programa e analisar dados. Ela permite escrever e rodar códigos em Python sem a necessidade de instalar nenhum programa. Além disso, é poss[ivel ter acesso a processadores poderosos, inclusive de GPUs, se necessário (mas pagando).

Para usar o google colab, precisamos de uma conta google, o que nós já temos com nosso e-mail usp.
Vamos acessar o endeeço: https://colab.google

Vamos clicar em new notebook.
Vamos renomear o arquivo para aula_llm.ipynb

A teminação diz que é um netebook. Que é como se fosse um Rmarkdown no R, só que nesse caso, hospedado online.


https://macartan.github.io/dd_bootcamp/dd.html#/using-a-design-1
https://macartan.github.io/dd_bootcamp/exercises.html
https://gist.github.com/saudiwin/dd0edec5786c7edb393bd84615aafb45

https://www.datacamp.com/tutorial/fine-tuning-openais-gpt-4-step-by-step-guide
https://community.revelo.com.br/tutorial-aplicacao-do-fine-tuning-para-treinamento-no-chatgpt/

<!--chapter:end:12-LLMs.Rmd-->

# Interferência, spillover e dinâmica


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Agora iremos relaxar algumas simplifcações do modelo de Resultados potenciais que vimos até agora.

## Suposições simplifcadoras

1. Tratamento binário
2. Único período de tempo (um tratamento "within unit" )
3. SUTVA

## PO com tratamento de múltiplos valores (multi-valued)

### Multi-valued discreto

Vamos estender o modelo de tratamewnto binário começando por tratamentos discretos. Digamos que temos $D_i \in \{0, 1, ..., d\}$, isto é, tratamentos ordenados. Por exemplo, múltiplas categorias de uma política pública (100 reais, 200 reais, 300 reais etc.). Definimos o resultado potencial da unidade $i$ para qualquer $d \in D$ como $Y_i(d)$

Nós vamos precisar da suposição de ignorability forte. 

$\tau_i(D, D') = Y_i(d) - Y_i(d')$, ou seja, o efeito causal entre dois níveis do tratamento. Como antes, podemos computar a esperança: $\mathbb{E}[\tau_i(D, D')] = \mathbb{E}[Y_i(d) - Y_i(d')]$. E se ignorability forte vale, então $\mathbb{E}[\tau_i(D, D')] = \mathbb{E}[Y_i|D_i = d] - \mathbb{E}[Y_i|D_i = d']$

Se quisermos, podemos trabalhar também com tratamentos não-ordenados. Por exemplo, dois tratamentos binários. Por exemplo, um tratamento é informação sobre corrupção de um candidato (recebe ou não a informação) e outro tratamento é informação sobre a raça do candidato (é branco ou não). $D_i \in \{0,1}^2\}$. Podemos modelar os resultados potenciais como dependendo do status dos dois tratamentos: $Y_i(D_{i1}, D_{i2})$ que geram quatro possibilidades ou resultados potenciais: $Y(0,0)$, $Y(1,0)$, $Y(0,1)$, $Y(1,1)$.

Exemplo onde mesmo com atribuição aleatória, há efeitos não-identificados. Aleatoriamente atribuir $D_1$ e, para os que receberam $D_1$, aleatoriamente atribui $D-2$. Onde isso poderia acontecer? Primeira e segunda dose de vacina! Por definição, a segunda dose só é dada para quem recebeu a primeira dose. Nunca é possível estimar efeito relativo a $Y_i(0,1)$, isto é, o resultado potencial de quem não recebeu a primeira dose, mas recebeu a segunda. Essa é uma pessoa que recebeu a primeira dose quando a segunda estava sendo aplicada.

## Dinâmica

Considere que agora nós observamos $T$ períodos de tempo para uma unidade: $Y_i$ = (Y_{i1}, Y_{i2}, ..., Y_{iT}). Para cada período, há um tratamento $D_{it} \in \{0,1\}$, isto é, sempre binário. Chamamos de $\mathbf{D_i} = (D_{i1}, D_{i2}, ..., D_{iT})$ o vetor de tratamentos em todos os $T$ períodos. Implicitamente, muitas pessoas abordam modelos dinâmicos supondo que podemos olhar apenas para o resultado pontencial para a unidade $i$ no período $t$, ou seja, $Y_{it}(D_{it})$. Porém, isso significa que apenas o tratamento do período $t$ impacta o resultado potencial do período $t$. De maneira mais geral, teríamos: $\mathbf{D_i} = (D_{i1}, D_{i2}, ..., D_{iT})$ e definiríamos o resultado potencial no período $t$ como $Y_{it}(\mathbf{D_i})$. $Y(\mathbf{D})$. Nesse caso, fomos para o lado oposto: tratamentos futuros impactando o resultado potencial do presente.  Isso não necessariamente significa que o futuro afeta o passado. Pode ocorrer por antecipação de tratamentos futuros. De todo modo, também parece extremo. Ainda assim, continuamos evitando a possibilidade de spillovers.

Uma suposição comum, portanto, é a de não-antecipação, que pode ser representada por: $Y_{it}(d_1, d_2, ..., d_t, d_{t+1}, ..., d_T) = Y_{it}(d_1, d_2, ..., d_t)$. Ou seja, os resultados potenciais até $t$ não dependem dos resultados potenciais após essa data.

Outra suposição comum é: ausência de efeitos dinâmicos:
$$Y_{it}(d_1, d_2, ..., d_t) = Y_{it}(d_t)$$
Em palavras, essa suposição requer que o resultado potencial do presente não dependa dos tratamentos passados. Essa suposição é também chamada de "no carry-over-effects hypothesis". Ela é bem restritiva. Mesmo um desenho em que a aleatorização é executada a cada período de maneira independente pode ter "carry-over-effects" se o resultado do período anterior impactar o resultado do período presente.

Modelos de "impulse response function" estão interessados em estimar justamente "carry over effects". ver https://donskerclass.github.io/CausalEconometrics/TimeSeries.html


Considere um modelo de regressão tradicional para dados dinâmicos: $y_{it} = \alpha + \beta x_{it} + e_{it}$. Nós já sabemos que uma forma de de pensar a identificação causal é imaginar um experimento aleatório controlado. O que significa, em primeiro lugar, escolher aleatoriamente o tratamento nesse caso? Uma possibilidade é imaginar que a cada período o tratamento é aleatoriamente atribuído, independentemente dos períodos anteriores. No fundo, é como uma multi-valued treatment. Qual condição de ignorability estamos satisfazendo nesse caso? Se apenas o tratamento presente impacta o resultado potencial, isto é, $Y_{it}(D_{it})$, então temos:

1. Baseline randomization: $Y(D_{it}) \perp D_{it}$. Ou seja, o resultado potencial no período $t$ é independente do mecanismo de atribuição do tratamento. Essa suposição implica exogeneidade estrita.

2. Ignorability sequencial (Sequential Unconfoundedness). Assume que, conditional à história passada observada de tratamentos e co-variáveis, o tratamento corrente é independente de resultados potenciais.

Nós iremos aprofundar essas questões nas aulas sobre DiD e Efeitos Fixos. Por ora, quero notar que no fundo estamos falando de spillovers no tempo, isto é, tratamento no tempo $t$ impatacando resultados potenciais de períodos furutos $t+(1:k)$, em que $k >0$.

## Interferência

Interferência ocorre quando o resultado potencial de uma unidade depende do tratamento de outra unidade. Tipicamente, em ciências sociais, spillovers podem envolver:

1. Efeitos de pares

2. Spillovers espaciais

3. Interações políticas (restrições orçamentárias)

Para modelar interferência, é necessário enriquecer nosso framework, introduzindo definições adicionais e alterando os pressupostos chave. Tipicamente nós modelamos com a suposição de que a interferência ocorre apenas em um subgrupo de unidades, isto é, o resultado potencial não depende do status de tratamento de todas as unidades, mas tão somente de um grupo específico. Além disso, também é comum ser necessário a suposição de anonimidade, isto é, os pares de um grupo importam, mas não quem são os pares, no sentido de que cada par teria um efeito esepcífico e único sobre uma unidade. Essa é uma área de pesqquisa ativa na inferência causal, mas ainda pouco incorporada na ciência política, em particular nas RIs, mas não só.

Referências chave são:
Charles F Manski. Identification of treatment response with social interactions. The Econometrics Journal, 16(1):S1–S23, 2013.

Peter M Aronow and Cyrus Samii. Estimating average causal effects under general interference, with application to a social network experiment. Annals of Applied Statistics, 11(4):1912–1947, 2017.

Bowers J, Fredrickson MM, Panagopoulos C. Reasoning about Interference Between Units: A General Framework. Political Analysis. 2013;21(1):97-124. doi:10.1093/pan/mps038






<!--chapter:end:inteferencia_dinamica.Rmd-->

